<div class="announce instapaper_body md" data-path="README.md" id="readme">
 <article class="markdown-body entry-content" itemprop="text">
  <table>
   <thead> 
    <tr> 
     <th>CI service</th> 
     <th>Status</th> 
     <th>Description</th> 
    </tr> 
   </thead>
   <tbody> 
    <tr> 
     <td>Travis</td> 
     <td><a href="https://travis-ci.org/gzoller/ScalaJack" target="_blank"><img src="https://camo.githubusercontent.com/0ed1a5336f71d8089b6946cab4a9fb3ca1eb4ad2/68747470733a2f2f7472617669732d63692e6f72672f677a6f6c6c65722f5363616c614a61636b2e706e673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.org/gzoller/ScalaJack.png?branch=master" style="max-width:100%;"></a></td> 
     <td>Linux container tests</td> 
    </tr> 
   </tbody>
  </table> 
  <h1><a id="user-content-scalajack" class="anchor" href="https://github.com/gzoller/scalajack#scalajack" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>ScalaJack</h1> 
  <p>Very fast JSON parser/generator for Scala case classes using Jackson that requires virtually no annotations or "helper" code.</p> 
  <p>Advanced Features:</p> 
  <ul> 
   <li>Handles tuples</li> 
   <li>Limited 'any' support</li> 
   <li>Handles default values for case class fields</li> 
   <li>Rich configuration of trait type hint/value</li> 
   <li>Supports value classes</li> 
   <li>Pluggable reader/render (for non-JSON encodings in the future)</li> 
  </ul> 
  <h1><a id="user-content-use" class="anchor" href="https://github.com/gzoller/scalajack#use" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Use</h1> 
  <p>ScalaJack is extremely simple to use.</p> 
  <p>Include it in your projects by adding the following to your build.sbt:</p> 
  <pre><code>libraryDependencies ++= Seq("co.blocke" %% "scalajack" % "4.8.3")
</code></pre> 
  <p>If you want to use the optional MongoDB serialization support include this as well:</p> 
  <pre><code>libraryDependencies ++= Seq("co.blocke" %% "scalajack_mongo" % "4.8.3")
</code></pre> 
  <p>ScalaJack is hosted on Bintray/JCenter now so if you're using sbt v0.13.9+ you should find it with no issues.</p> 
  <p>If you're on sbt v0.13.11 you may need to enable the bintray resolver in your build.sbt with</p> 
  <div class="highlight highlight-source-scala">
   <pre>useJCenter <span class="pl-k">:</span><span class="pl-k">=</span> <span class="pl-c1">true</span></pre>
  </div> 
  <p>Now you're good to go! Let's use ScalaJack in your project to serialize/de-serialize a case class object into JSON:</p> 
  <pre><code>import co.blocke.scalajack._

val sj = ScalaJack()
val js = sj.render( myCaseObj )  // serialization
val myObj = sj.read[MyCaseClass](js) // deserialization
</code></pre> 
  <p>Couldn't be simpler.</p> 
  <h3><a id="user-content-trait-support" class="anchor" href="https://github.com/gzoller/scalajack#trait-support" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Trait support</h3> 
  <p>ScalaJack can handle traits too. To do this you'll need the help of a type hint in the JSON. This tells ScalaJack what actual class to create in support of the trait.</p> 
  <p>The default type hint is "_hint" but you can set whatever you want (very powerful for 3rd party JSON!) You set your own type hint with a VisitorContext object as shown below. Don't forget to use the same type hint name for render and read.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">package</span> <span class="pl-en">com.myproj</span>

<span class="pl-k">trait</span> <span class="pl-en">Pet</span> { <span class="pl-k">val</span> <span class="pl-en">name</span><span class="pl-k">:</span><span class="pl-k">String</span> }
<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Dog</span>( name<span class="pl-k">:</span><span class="pl-k">String</span> ) <span class="pl-k">extends</span> <span class="pl-e">Pet</span>
<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Cat</span>( name<span class="pl-k">:</span><span class="pl-k">String</span> ) <span class="pl-k">extends</span> <span class="pl-e">Pet</span>

<span class="pl-k">val</span> <span class="pl-en">p</span> <span class="pl-k">:</span> <span class="pl-en">Pet</span> <span class="pl-k">=</span> <span class="pl-en">Dog</span>(<span class="pl-s"><span class="pl-pds">"</span>Fido<span class="pl-pds">"</span></span>)
<span class="pl-k">val</span> <span class="pl-en">sj</span> <span class="pl-k">=</span> <span class="pl-en">ScalaJack</span>()
<span class="pl-k">val</span> <span class="pl-en">js</span> <span class="pl-k">=</span> sj.render(p)  <span class="pl-c">// {"_hint":"com.myproj.Dog","name":"Fido"}</span>
<span class="pl-k">val</span> <span class="pl-en">vc</span> <span class="pl-k">=</span> <span class="pl-en">VisitorContext</span>(hintMap<span class="pl-k">=</span><span class="pl-en">Map</span>(<span class="pl-s"><span class="pl-pds">"</span>default<span class="pl-pds">"</span></span><span class="pl-k">-</span><span class="pl-k">&gt;</span><span class="pl-s"><span class="pl-pds">"</span>kind<span class="pl-pds">"</span></span>))
<span class="pl-k">val</span> <span class="pl-en">js2</span> <span class="pl-k">=</span> sj.render(p,vc) <span class="pl-c">// {"kind":"com.myproj.Dog","name":"Fido"}</span>

<span class="pl-c">// Be sure to match type hints when reading!</span>
<span class="pl-k">val</span> <span class="pl-en">d1</span> <span class="pl-k">=</span> sj.read[<span class="pl-en">Pet</span>](js)
<span class="pl-k">val</span> <span class="pl-en">d2</span> <span class="pl-k">=</span> sj.read[<span class="pl-en">Pet</span>](js2,vc)</pre>
  </div> 
  <p>There's one more cool trick we can do with traits. Imagine you're parsing JSON from a 3rd party (i.e. you don't control its structure) and you're modeling nested traits but want the type hint field to be different. ScalaJack's VisitorContext object allows you specify per-trait hints like so:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">package</span> <span class="pl-en">com.myproj</span>

<span class="pl-k">trait</span> <span class="pl-en">Animal</span> {
    <span class="pl-k">val</span> <span class="pl-en">name</span><span class="pl-k">:</span><span class="pl-k">String</span>
}
<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Dog</span>(name<span class="pl-k">:</span><span class="pl-k">String</span>) <span class="pl-k">extends</span> <span class="pl-e">Animal</span>
<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Cat</span>(name<span class="pl-k">:</span><span class="pl-k">String</span>) <span class="pl-k">extends</span> <span class="pl-e">Animal</span>
<span class="pl-k">trait</span> <span class="pl-en">Pet</span> {
    <span class="pl-k">val</span> <span class="pl-en">kind</span><span class="pl-k">:</span><span class="pl-en">Animal</span>
    <span class="pl-k">val</span> <span class="pl-en">food</span><span class="pl-k">:</span><span class="pl-k">String</span>
}
<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">NicePet</span>(kind<span class="pl-k">:</span><span class="pl-en">Animal</span>, food<span class="pl-k">:</span><span class="pl-k">String</span>) <span class="pl-k">extends</span> <span class="pl-e">Pet</span>
<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">GrumpyPet</span>(kind<span class="pl-k">:</span><span class="pl-en">Animal</span>, food<span class="pl-k">:</span><span class="pl-k">String</span>) <span class="pl-k">extends</span> <span class="pl-e">Pet</span>

<span class="pl-k">val</span> <span class="pl-en">pets</span> <span class="pl-k">=</span> <span class="pl-en">List</span>(<span class="pl-en">NicePet</span>(<span class="pl-en">Dog</span>(<span class="pl-s"><span class="pl-pds">"</span>Fido<span class="pl-pds">"</span></span>),<span class="pl-s"><span class="pl-pds">"</span>kibbles<span class="pl-pds">"</span></span>),<span class="pl-en">GrumpyPet</span>(<span class="pl-en">Cat</span>(<span class="pl-s"><span class="pl-pds">"</span>Meow<span class="pl-pds">"</span></span>),<span class="pl-s"><span class="pl-pds">"</span>fish<span class="pl-pds">"</span></span>))
<span class="pl-k">val</span> <span class="pl-en">sj</span> <span class="pl-k">=</span> <span class="pl-en">ScalaJack</span>()
<span class="pl-k">val</span> <span class="pl-en">vc</span> <span class="pl-k">=</span> <span class="pl-en">VisitorContext</span>(hintMap <span class="pl-k">=</span> <span class="pl-en">Map</span>(
        <span class="pl-s"><span class="pl-pds">"</span>default<span class="pl-pds">"</span></span><span class="pl-k">-</span><span class="pl-k">&gt;</span><span class="pl-s"><span class="pl-pds">"</span>_hint<span class="pl-pds">"</span></span>,
        <span class="pl-s"><span class="pl-pds">"</span>com.myproj.Pet<span class="pl-pds">"</span></span><span class="pl-k">-</span><span class="pl-k">&gt;</span><span class="pl-s"><span class="pl-pds">"</span>_happy<span class="pl-pds">"</span></span>,
        <span class="pl-s"><span class="pl-pds">"</span>com.myproj.Animal<span class="pl-pds">"</span></span><span class="pl-k">-</span><span class="pl-k">&gt;</span><span class="pl-s"><span class="pl-pds">"</span>_kind<span class="pl-pds">"</span></span>))
<span class="pl-k">val</span> <span class="pl-en">js</span> <span class="pl-k">=</span> sj.render(pets,vc)
<span class="pl-c">// produces: [{"_happy":"com.myproj.NicePet","kind":{"_kind":"com.myproj.Dog","name":"Fido"},"food":"kibbles"},{"_happy":"com.myproj.GrumpyPet","kind":{"_kind":"com.myproj.Cat","name":"Meow"},"food":"fish"}]</span></pre>
  </div> 
  <p>Note how you get different type hints for specific traits. This can be invaluable for advanced JSON parsing of 3rd party data.</p> 
  <h1><a id="user-content-custom-value-class-json" class="anchor" href="https://github.com/gzoller/scalajack#custom-value-class-json" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Custom Value Class JSON</h1> 
  <p><strong>NOTE:</strong> Custom value class JSON handling has changed since ScalaJack 4.7. We no longer use the VisitorContext.</p> 
  <p>Let's imagine we have a value class PosixDate that has a long as its single value type, holding a Unix timestamp. Let's further assume we use this class in a case class for server stats like this:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">class</span> <span class="pl-en">PosixDate</span>( <span class="pl-k">val</span> <span class="pl-en">ts</span><span class="pl-k">:</span><span class="pl-k">Long</span> <span class="pl-k">=</span> (<span class="pl-k">new</span> <span class="pl-en">Date</span>()).getTime ) <span class="pl-k">extends</span> <span class="pl-e">AnyVal</span> {
    <span class="pl-k">def</span> <span class="pl-en">toDate</span> <span class="pl-k">:</span> <span class="pl-en">Date</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Date</span>(ts)
    <span class="pl-k">def</span> <span class="pl-en">isBefore</span>( pd<span class="pl-k">:</span><span class="pl-en">PosixDate</span> ) <span class="pl-k">=</span> <span class="pl-v">this</span>.ts <span class="pl-k">&lt;</span> pd.ts
    <span class="pl-k">def</span> <span class="pl-en">isAfter</span>( pd<span class="pl-k">:</span><span class="pl-en">PosixDate</span> )  <span class="pl-k">=</span> <span class="pl-v">this</span>.ts <span class="pl-k">&gt;</span> pd.ts
    <span class="pl-k">override</span> <span class="pl-k">def</span> <span class="pl-en">toString</span>() <span class="pl-k">=</span> ts.toString
}

<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">ServerStats</span>( instanceName<span class="pl-k">:</span><span class="pl-k">String</span>, upSince<span class="pl-k">:</span><span class="pl-en">PosixDate</span> )</pre>
  </div> 
  <p>Good enough. Now let's render some JSON:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">ss</span> <span class="pl-k">=</span> <span class="pl-en">ServerStats</span>( <span class="pl-s"><span class="pl-pds">"</span>admin<span class="pl-pds">"</span></span>, <span class="pl-k">new</span> <span class="pl-en">PosixDate</span>() )
<span class="pl-k">val</span> <span class="pl-en">js</span> <span class="pl-k">=</span> sj.render( ss )  <span class="pl-c">// Output: {"instanceName":"admin","upSince":1383317215}</span></pre>
  </div> 
  <p>Hmm... For my use I might want something different than that Long numeric output. I may want a specific format for my timestamp in the JSON. I can accomplish this by providing a companion object to my value class that extends a special trait, <strong>ValueClassCustom</strong>. This trait defines read and render functions as PartialFunctions, which allows you to provide whatever reading or rendering logic you need for a given "flavor" of parsing. </p> 
  <p>The two flavors supported to day are: <strong>JsonKind</strong> and <strong>MongoKind</strong></p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">object</span> <span class="pl-en">PosixDate</span> <span class="pl-k">extends</span> <span class="pl-e">ValueClassCustom</span> {
  <span class="pl-k">def</span> <span class="pl-en">read</span><span class="pl-k">:</span><span class="pl-en">PartialFunction</span>[(<span class="pl-en">KindMarker</span>,_), <span class="pl-k">Long</span>] <span class="pl-k">=</span> {
      <span class="pl-k">case</span> (j<span class="pl-k">:</span><span class="pl-en">JsonKind</span>,js<span class="pl-k">:</span><span class="pl-k">String</span>) <span class="pl-k">=&gt;</span> 
          <span class="pl-en">DateTimeFormat</span>.forPattern(<span class="pl-s"><span class="pl-pds">"</span>MMMM, yyyy<span class="pl-pds">"</span></span>).parseDateTime(js).toDate.getTime
  }
  <span class="pl-k">def</span> <span class="pl-en">render</span><span class="pl-k">:</span><span class="pl-en">PartialFunction</span>[(<span class="pl-en">KindMarker</span>,_),<span class="pl-en">Any</span>] <span class="pl-k">=</span> {
      <span class="pl-k">case</span> (j<span class="pl-k">:</span><span class="pl-en">JsonKind</span>,pd<span class="pl-k">:</span><span class="pl-k">Long</span>) <span class="pl-k">=&gt;</span> 
          <span class="pl-c1">'"'</span><span class="pl-k">+</span><span class="pl-en">DateTimeFormat</span>.forPattern(<span class="pl-s"><span class="pl-pds">"</span>MMMM, yyyy<span class="pl-pds">"</span></span>).print( <span class="pl-k">new</span> <span class="pl-en">DateTime</span>( <span class="pl-k">new</span> <span class="pl-en">java.util.Date</span>(pd)) )<span class="pl-k">+</span><span class="pl-c1">'"'</span>
  }
}</pre>
  </div> 
  <p>Admittedly, the date formatting code here is a bit tortured, but to prove a point. You'd use it like this:</p> 
  <div class="highlight highlight-source-scala">
   <pre>  <span class="pl-k">val</span> <span class="pl-en">sj</span> <span class="pl-k">=</span> <span class="pl-en">ScalaJack</span>()
  <span class="pl-k">val</span> <span class="pl-en">one</span> <span class="pl-k">=</span> <span class="pl-en">ServerStats</span>(<span class="pl-s"><span class="pl-pds">"</span>Admin<span class="pl-pds">"</span></span>, <span class="pl-k">new</span> <span class="pl-en">PosixDate)</span>
  println(<span class="pl-s"><span class="pl-pds">"</span>1: <span class="pl-pds">"</span></span><span class="pl-k">+</span>one)
  <span class="pl-k">val</span> <span class="pl-en">js</span> <span class="pl-k">=</span> sj.render(one)  <span class="pl-c">// outputs {"instanceName":"Admin","upSince":"July, 2016"}</span>
  println(<span class="pl-s"><span class="pl-pds">"</span>2: <span class="pl-pds">"</span></span><span class="pl-k">+</span>js)
  println(<span class="pl-s"><span class="pl-pds">"</span>3: <span class="pl-pds">"</span></span><span class="pl-k">+</span>sj.read[<span class="pl-en">ServerStats</span>](js))</pre>
  </div> 
  <p>The Long (the internal representation of your PosixDate value class) is successfully read and rendered using whatever formatting rules you specify.</p> 
  <p>Some tips:</p> 
  <ul> 
   <li>For JSON parsing the first element of the tuple in read is JsonKind, and the second is a String (the raw JSON value).</li> 
   <li>For rendering JSON, the second tuple element of render is the internal data type, or Long in our example. </li> 
   <li>For rendering JSON note that quotes are included in the result. If your value was numeric or boolean you wouldn't need these.</li> 
  </ul> 
  <h1><a id="user-content-custom-renderings-for-simple-java-objects-and-primitives" class="anchor" href="https://github.com/gzoller/scalajack#custom-renderings-for-simple-java-objects-and-primitives" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Custom Renderings for simple Java objects and Primitives</h1> 
  <p>This feature is similar to the previous section, Custom Value Class JSON, however it doesn't require you to wrap your objects in a value class. Neato!</p> 
  <p>Let's look at a similar example using two types: org.joda.time.DateTime, and java.nio.charset.Charset. The first is a built-in ScalaJack primitive and the second is a simple Java object.</p> 
  <p><strong>Note</strong>: <em>"Simple" here means a class can be rendered and re-read with just one field. ScalaJack does not (yet) support a more sophisticated multi-field rendering of a Java class.</em></p> 
  <p>You're already familiar with the use case from the last section, so let's go right to code:</p> 
  <div class="highlight highlight-source-scala">
   <pre>    <span class="pl-c">// We're going to override the DateTime default rendering</span>
    <span class="pl-k">object</span> <span class="pl-en">Overrides</span> {
        <span class="pl-k">type</span> <span class="pl-en">SpecialTime</span> <span class="pl-k">=</span> <span class="pl-en">DateTime</span>
    }
    <span class="pl-k">import</span> <span class="pl-v">Overrides.</span><span class="pl-v">_</span>

    <span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">ShowMe</span>( when<span class="pl-k">:</span><span class="pl-en">SpecialTime</span>, again<span class="pl-k">:</span><span class="pl-en">DateTime</span>, charset<span class="pl-k">:</span><span class="pl-en">Charset</span> )

    <span class="pl-k">val</span> <span class="pl-en">specialTimeHandler</span> <span class="pl-k">=</span> <span class="pl-en">CustomReadRender</span>(
        {
            <span class="pl-k">case</span> (j<span class="pl-k">:</span><span class="pl-en">JsonKind</span>,js<span class="pl-k">:</span><span class="pl-k">String</span>) <span class="pl-k">=&gt;</span> <span class="pl-en">ISODateTimeFormat</span>.dateTime().parseDateTime(js)
        },
        {
            <span class="pl-k">case</span> (j<span class="pl-k">:</span><span class="pl-en">JsonKind</span>,thing<span class="pl-k">:</span><span class="pl-en">DateTime</span>) <span class="pl-k">=&gt;</span> <span class="pl-c1">'"'</span><span class="pl-k">+</span><span class="pl-en">ISODateTimeFormat</span>.dateTime().withZoneUTC().print(thing)<span class="pl-k">+</span><span class="pl-c1">'"'</span>
        }
    )
    <span class="pl-k">val</span> <span class="pl-en">charsetHandler</span> <span class="pl-k">=</span> <span class="pl-en">CustomReadRender</span>(
        {
            <span class="pl-k">case</span> (j<span class="pl-k">:</span><span class="pl-en">JsonKind</span>,js<span class="pl-k">:</span><span class="pl-k">String</span>) <span class="pl-k">=&gt;</span> <span class="pl-en">Charset</span>.forName(js)
        },
        {
            <span class="pl-k">case</span> (j<span class="pl-k">:</span><span class="pl-en">JsonKind</span>,thing<span class="pl-k">:</span><span class="pl-en">Charset</span>) <span class="pl-k">=&gt;</span> <span class="pl-c1">'"'</span><span class="pl-k">+</span>thing.toString<span class="pl-k">+</span><span class="pl-c1">'"'</span>
        }
    )

    <span class="pl-k">val</span> <span class="pl-en">handlerMap</span> <span class="pl-k">=</span> <span class="pl-en">Map</span>(
        <span class="pl-s"><span class="pl-pds">"</span>com.my.path.Overrides.SpecialTime<span class="pl-pds">"</span></span><span class="pl-k">-</span><span class="pl-k">&gt;</span>specialTimeHandler,
        <span class="pl-s"><span class="pl-pds">"</span>java.nio.charset.Charset<span class="pl-pds">"</span></span><span class="pl-k">-</span><span class="pl-k">&gt;</span>charsetHandler
        )

    <span class="pl-k">val</span> <span class="pl-en">sjJS</span>  <span class="pl-k">=</span> <span class="pl-en">ScalaJack</span>()
    <span class="pl-k">val</span> <span class="pl-en">vc</span> <span class="pl-k">=</span> <span class="pl-en">VisitorContext</span>().copy(customHandlers <span class="pl-k">=</span> handlerMap)

    <span class="pl-k">val</span> <span class="pl-en">showMe</span> <span class="pl-k">=</span> <span class="pl-en">ShowMe</span>( <span class="pl-k">new</span> <span class="pl-en">DateTime,</span> <span class="pl-k">new</span> <span class="pl-en">DateTime,</span> <span class="pl-en">Charset</span>.defaultCharset )
    <span class="pl-k">val</span> <span class="pl-en">js</span> <span class="pl-k">=</span> sjJS.render(showMe,vc) <span class="pl-c">// Don't forget the vc!!</span></pre>
  </div> 
  <p>This will produce some JSON looking like this:</p> 
  <div class="highlight highlight-source-json">
   <pre>{<span class="pl-s"><span class="pl-pds">"</span>when<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>2016-07-27T00:35:51.977Z<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>again<span class="pl-pds">"</span></span>:<span class="pl-c1">1469579752025</span>,<span class="pl-s"><span class="pl-pds">"</span>charset<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>UTF-8<span class="pl-pds">"</span></span>}</pre>
  </div> 
  <p>Notice something cool... The fields when and again are both basically DateTime values. We set when to a custom type then mapped that type to a custom handler, so the when value got custom read/render treatment, while the vanilla DateTime variant was handled in the default way.</p> 
  <p>There is no default handling for a Java class like Charset! You must always provide a CustomHandler for a Java type or ScalaJack will give you an error.</p> 
  <h1><a id="user-content-parse-or-else-for-traits" class="anchor" href="https://github.com/gzoller/scalajack#parse-or-else-for-traits" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Parse Or Else for Traits</h1> 
  <p>Occasionally you may be parsing certain traits that may fail--and that's ok. A good example might be something like this JSON for a Configuration object:</p> 
  <div class="highlight highlight-source-json">
   <pre>case class Module(name:String,...)
case class Configuration( modules: List[<span class="pl-ii">Module</span>] )

{
    <span class="pl-s"><span class="pl-pds">"</span>modules<span class="pl-pds">"</span></span>:[
        { 
            <span class="pl-s"><span class="pl-pds">"</span>_hint<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>com.foo.MyModule<span class="pl-pds">"</span></span>,
            <span class="pl-s"><span class="pl-pds">"</span>name<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>Something<span class="pl-pds">"</span></span>,
            <span class="pl-ii">...</span>
        },
        { 
            <span class="pl-s"><span class="pl-pds">"</span>_hint<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>com.foo.OtherModule<span class="pl-pds">"</span></span>,
            <span class="pl-s"><span class="pl-pds">"</span>name<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>Something Else<span class="pl-pds">"</span></span>,
            <span class="pl-ii">...</span>
        }
    ]
}</pre>
  </div> 
  <p>If this is a shared configuration file it's possible that you don't have the code for OtherModule, so when you try to parse this JSON it will (by default) explode with a ClassNotFoundException for com.foo.OtherModule. There are times when this is exactly what you want--when you should indeed have that class in your path somewhere, but other times it's ok to fail. Maybe I don't care about any modules other than mine so I intend to ignore OtherModule anyway, even if I had it.</p> 
  <p>For those time when its ok to fail to parse a concrete class implementing a trait (i.e. a _hint class not found) ScalaJack provides a parseOrElse feature in the VisitorContext. It allows you to specify a default concrete object to use if it can't successfully parse the given _hint for a trait. Use it like this:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">trait</span> <span class="pl-en">MyTrait</span>
<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">SomeDefault</span>(name<span class="pl-k">:</span><span class="pl-k">String</span>) <span class="pl-k">extends</span> <span class="pl-e">MyTrait</span>
<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Foo</span>() <span class="pl-k">extends</span> <span class="pl-e">MyTrait</span>

<span class="pl-k">val</span> <span class="pl-en">vc</span> <span class="pl-k">=</span> <span class="pl-en">VisitorContext</span>().copy( parseOrElse <span class="pl-k">=</span> <span class="pl-en">Map</span>(<span class="pl-s"><span class="pl-pds">"</span>com.foo.MyTrait<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>com.foo.SomeDefault<span class="pl-pds">"</span></span>)
<span class="pl-k">val</span> <span class="pl-en">sj</span> <span class="pl-k">=</span> <span class="pl-en">ScalaJack</span>()

<span class="pl-k">val</span> <span class="pl-en">myModule</span> <span class="pl-k">=</span> sj.read[<span class="pl-en">Configuration</span>](configJS,vc).find(_.name <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>Something<span class="pl-pds">"</span></span>).<span class="pl-c1">asInstanceOf</span>[<span class="pl-en">MyModule</span>]</pre>
  </div> 
  <p>Using the VisitorContext (vc) during read with parseOrElse set, when ScalaJack parsed the _hint for com.foo.OtherModule it caught the ClassNotFound exception and noted that you asked to substitude the default of SomeDefault (which we don't care about here), which is what it returns so that the Configuration parse doesn't die.</p> 
  <h1><a id="user-content-mongodb-persistence" class="anchor" href="https://github.com/gzoller/scalajack#mongodb-persistence" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>MongoDB Persistence</h1> 
  <p><strong>NOTE:</strong> As of version 4.5.1 ScalaJack supports the new asynchronous MongoDB drivers for Scala, deprecating Casbah support. If you need Casbah, version 4.4.6 is the last version supporting Casbah.</p> 
  <p>ScalaJack doesn't wrap the MongoDB persistence libraries--that's not its mission. It does provide a way to convert case classes (and traits)to/from Documents. You'll need to include the mongo support package:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">co.blocke.scalajack.</span><span class="pl-v">_</span>
<span class="pl-k">import</span> <span class="pl-v">mongo.</span><span class="pl-v">_</span>

<span class="pl-k">val</span> <span class="pl-en">sjMongo</span> <span class="pl-k">=</span> <span class="pl-en">ScalaJack</span>(<span class="pl-en">MongoFlavor</span>()) <span class="pl-c">// produce a Mongo-flavored ScalaJack</span>
<span class="pl-k">val</span> <span class="pl-en">mydbo</span>  <span class="pl-k">=</span> sjMongo.render( myCaseClass )
<span class="pl-k">val</span> <span class="pl-en">myCC</span>   <span class="pl-k">=</span> sjMongo.read[<span class="pl-en">MyClass</span>]( mydbo )</pre>
  </div> 
  <p>The VisitorContext modifications work here too, as before with JSON.</p> 
  <p>You can (and should) specify the key field(s) for your classes with the @DBKey annotation as shown here:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Sample</span>( <span class="pl-k">@</span><span class="pl-en">DBKey</span> lastName<span class="pl-k">:</span><span class="pl-k">String</span>, birthDate<span class="pl-k">:</span><span class="pl-k">Long</span>, hobbies<span class="pl-k">:</span><span class="pl-en">List</span>[<span class="pl-k">String</span>] )</pre>
  </div> 
  <p>Compound keys are also supported:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Sample</span>( <span class="pl-k">@</span><span class="pl-en">DBKey</span> lastName<span class="pl-k">:</span><span class="pl-k">String</span>, <span class="pl-k">@</span><span class="pl-en">DBKey</span> birthDate<span class="pl-k">:</span><span class="pl-k">Long</span>, hobbies<span class="pl-k">:</span><span class="pl-en">List</span>[<span class="pl-k">String</span>] )</pre>
  </div> 
  <p>Support has been added for Mongo's ObjectId type if you wish to use this directly.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Sample</span>( <span class="pl-k">@</span><span class="pl-en">DBKey</span> _id<span class="pl-k">:</span><span class="pl-en">ObjectId</span>, stuff<span class="pl-k">:</span><span class="pl-k">Int</span> )</pre>
  </div> 
  <p>Once you have your Document, use MongoDB's native Scala API as you normally would.</p> 
  <h1><a id="user-content-csv-support" class="anchor" href="https://github.com/gzoller/scalajack#csv-support" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>CSV Support</h1> 
  <p>CSV support is provided but by necessity is very limited. CSV itself is not sufficiently expressive to handle complex data structures such as fields n a class that are themselves classes, collections, etc. Therefore the following rules apply:</p> 
  <ul> 
   <li>Case class only support</li> 
   <li>Classes must be "flat" 
    <ul> 
     <li>no List/Array, Map, or collection fields</li> 
     <li>no fields that are classes</li> 
    </ul></li> 
   <li>Field ordering in the CSV must match the declared field order of the class</li> 
   <li>Optional fields of simple type are OK, for example Option<a href="https://github.com/gzoller/scalajack/blob/master/these%20will%20be%20read/rendered%20as%20empty%20csv:%20foo,,bar" target="_blank">String</a></li> 
   <li>Classes must be concrete. Traits are not allowed. (How would you supply the type hint?)</li> 
   <li>Parameterized classes are OK as long as the parameters conform to the above rules</li> 
  </ul> 
  <p>During a read of a CSV record, if a field is empty "foo,,bar" it may mean the empty value is optional, which will be read in as None. It may also mean that a field in the class has a default value on the constructor, in which case the default value is applied. If the class field corresponding to the empty spot in the CSV is neither Option nor a default-value field then it is viewed as an empty value.</p> 
  <h3><a id="user-content-usage" class="anchor" href="https://github.com/gzoller/scalajack#usage" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Usage</h3> 
  <p>CSV rendering is an inexact science, so here's how this works in ScalaJack. First you'll need to instantiate a ScalaJack instance with CSVFlavor as shown in the code below. Null values are represented as null in the CSV. null (unquoted) read in is a null value in the object. "null" (quoted) is a String with value "null" (not a real null value). For example "foo,null,bar" contains a null. "foo,"null",bar" shows a string having value "null". Confused yet?</p> 
  <p>Optional None is rendered as blank in the CSV and when read in, like "foo,,bar".</p> 
  <p>As per the (unofficial) CSV spec:</p> 
  <ul> 
   <li>Fields may be enclosed in double-quotes</li> 
   <li>String values containing double quotes <em>must</em> be enclosed by double quotes and the double-quote char in the string must be escaped by another double quote like this: "I read ""Lord of the Rings"" last year"</li> 
   <li>String values that contain a field separator (comma) must be enclosed in double quotes.</li> 
  </ul> 
  <p>Use CSV support like this:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Foo</span>(name<span class="pl-k">:</span><span class="pl-k">String</span>, age<span class="pl-k">:</span><span class="pl-k">Int</span>)
<span class="pl-k">val</span> <span class="pl-en">sjCSV</span>  <span class="pl-k">=</span> <span class="pl-en">ScalaJack</span>(<span class="pl-en">CSVFlavor</span>())
sjCSV.render( <span class="pl-en">Foo</span>(<span class="pl-s"><span class="pl-pds">"</span>Fred<span class="pl-pds">"</span></span>, <span class="pl-c1">32</span>) ) <span class="pl-c">// Fred,32</span>
sjCSV.read[<span class="pl-en">Foo</span>]( <span class="pl-s"><span class="pl-pds">"</span>Fred,32<span class="pl-pds">"</span></span> ) <span class="pl-c">// Foo("Fred",32)</span></pre>
  </div> 
  <h1><a id="user-content-mysql-support" class="anchor" href="https://github.com/gzoller/scalajack#mysql-support" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>MySQL Support</h1> 
  <p>The MySQL support provided in the ScalaJack 3.x series has been removed for the time being. I wasn't entirely happy with it. It may be back in a future release if there is a swell of people interested in it.</p> 
  <h1><a id="user-content-visitorcontext" class="anchor" href="https://github.com/gzoller/scalajack#visitorcontext" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>VisitorContext</h1> 
  <p>ScalaJack uses an optional VisitorContext object you can pass into read/render to control certain aspects of how data is processed. Looking at the definition of VisitorContext is a good starting point:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">VisitorContext</span>(
    <span class="pl-v">isCanonical</span>     : <span class="pl-k">Boolean</span> <span class="pl-k">=</span> <span class="pl-c1">true</span>,    <span class="pl-c">// allow non-string keys in Maps--not part of JSON spec</span>
    <span class="pl-v">isValidating</span>    : <span class="pl-k">Boolean</span> <span class="pl-k">=</span> <span class="pl-c1">false</span>,
    <span class="pl-v">estFieldsInObj</span>  : <span class="pl-k">Int</span>     <span class="pl-k">=</span> <span class="pl-c1">128</span>,
    <span class="pl-v">customHandlers</span>  : <span class="pl-en">Map</span>[<span class="pl-k">String</span>,<span class="pl-en">CustomReadRender</span>] <span class="pl-k">=</span> <span class="pl-en">Map</span>.empty[<span class="pl-k">String</span>,<span class="pl-en">CustomReadRender</span>],
    <span class="pl-v">parseOrElse</span>     : <span class="pl-en">Map</span>[<span class="pl-k">String</span>,<span class="pl-k">String</span>] <span class="pl-k">=</span> <span class="pl-en">Map</span>.empty[<span class="pl-k">String</span>,<span class="pl-k">String</span>],
    <span class="pl-v">hintMap</span>         : <span class="pl-en">Map</span>[<span class="pl-k">String</span>,<span class="pl-k">String</span>] <span class="pl-k">=</span> <span class="pl-en">Map</span>(<span class="pl-s"><span class="pl-pds">"</span>default<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>_hint<span class="pl-pds">"</span></span>),  <span class="pl-c">// per-class type hints (for nested classes)</span>
    <span class="pl-v">hintValueRead</span>   : <span class="pl-en">Map</span>[<span class="pl-k">String</span>,(<span class="pl-k">String</span>)<span class="pl-k">=&gt;</span><span class="pl-k">String</span>] <span class="pl-k">=</span> <span class="pl-en">Map</span>.empty[<span class="pl-k">String</span>,(<span class="pl-k">String</span>)<span class="pl-k">=&gt;</span><span class="pl-k">String</span>], <span class="pl-c">// per-class type hint value -&gt; class name</span>
    <span class="pl-v">hintValueRender</span> : <span class="pl-en">Map</span>[<span class="pl-k">String</span>,(<span class="pl-k">String</span>)<span class="pl-k">=&gt;</span><span class="pl-k">String</span>] <span class="pl-k">=</span> <span class="pl-en">Map</span>.empty[<span class="pl-k">String</span>,(<span class="pl-k">String</span>)<span class="pl-k">=&gt;</span><span class="pl-k">String</span>]  <span class="pl-c">// per-class type class name -&gt; hint value</span>
    )</pre>
  </div> 
  <p>Let's look at these fields one-by-one.</p> 
  <p><strong>isCanonical</strong>=true is standard JSON. In some strange situations you may wish JSON-like notation that does not use strings as keys. You would set this field to false to allow that. Note that this is <em>not</em> really JSON and won't many libraries (like Mongo) assume and require string-based keys for JSON objects.</p> 
  <p><strong>isValidating</strong> controls which of ScalaJack's 2 parsers is used. The non-validating parser (isValidating=false) is a bit faster but doesn't make much effort in telling you why JSON parsing failed. The validating parser is a little slower but has better error reporting.</p> 
  <p><strong>estFieldsInObj</strong> is also something you'll likely want to set for non-validating parsing. Part of its speed is pre-allocated buffers, so you'll need to guess a reasonable maximum field count for the largest expected object in your data. If you use the validating parser you can ignore this field as another reason the validating parser is slower is that it can auto-scale its buffers without your help.</p> 
  <p><strong>customHandlers</strong> is a map of class name to CustomReadRender object, which provides PartialFunctions for read and render operations by kind (JsonKind, MongoKind, etc.) This is how you implement custom renderings for either simple Java types and for overriding standard renderings for primitives.</p> 
  <p><strong>parseOrElse</strong> is a map of fully-qualified class names for traits to fully-qualified class names to concrete classes implementing those traits to be used as defaults if ScalaJack can't successfully find the given classes in the type hint (_hint) in the JSON.</p> 
  <p><strong>hintMap</strong> is a map of class name (fully-qualified) to trait type hint string. Note there must always be a "default" entry in your map or you risk breaking.</p> 
  <p><strong>hintValueRead/hintValueRender</strong> maps allow you to use strings other than fully-qualified class names as a hint value. This can be very valuable if the "discriminator" field for your JSON is provided by a 3rd party, or you'd like to hide the internal details of hint-handling from an external system. They key to both maps is the fully-qualified trait name. The value of hintValueRead is a function that accepts a String (the "friendly" hint value) and emits a fully-qualified class name. In a simple implementation this may just prepend a package hierarchy, a la "com.foo.something", but it can be whatever you want. hintValueRender goes the other way. It's values are functions accepting a String (a fully-qualified class name) and emits a friendly hint value.</p> 
  <h1><a id="user-content-viewspliceinto-feature" class="anchor" href="https://github.com/gzoller/scalajack#viewspliceinto-feature" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>View/SpliceInto Feature</h1> 
  <p>If you've ever had the need to support view "projections" to/from a large master object, these functions will help. Below is a contrived example of a User object that has some protected fields we don't want to easily project out (to make it save for a UI, for example):</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">User</span>(
   name<span class="pl-k">:</span><span class="pl-k">String</span>,
   age<span class="pl-k">:</span><span class="pl-k">Int</span>,
   password<span class="pl-k">:</span><span class="pl-k">String</span>,  <span class="pl-c">// don't want password or ssn going up to the UI</span>
   ssn<span class="pl-k">:</span><span class="pl-k">String</span>
)

<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">SafeUser</span>(
   name<span class="pl-k">:</span><span class="pl-k">String</span>,
   age<span class="pl-k">:</span><span class="pl-k">Int</span>
)

<span class="pl-k">val</span> <span class="pl-en">safe</span> <span class="pl-k">=</span> <span class="pl-en">ScalaJack</span>.view[<span class="pl-en">SafeUser</span>]( fullUser ) <span class="pl-c">// fullUser is of type User, safe will be SafeUser</span></pre>
  </div> 
  <p>Note that the field names and types of the view class (SafeUser above) must be exactly the same as the corresponding fields of the master class, and you shouldn't have extra fields that aren't present somewhere in the master class. Field order, however, is not important.</p> 
  <p>You can also go the other way...incorporating data from a view object back into a master object.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">updatedUser</span> <span class="pl-k">=</span> <span class="pl-en">ScalaJack</span>.spliceInto( user, newSafeUser ) <span class="pl-c">// updatedUser will be of type User</span></pre>
  </div> 
  <h1><a id="user-content-assumptions" class="anchor" href="https://github.com/gzoller/scalajack#assumptions" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Assumptions</h1> 
  <ul> 
   <li>Case classes (or traits for case classes) only</li> 
   <li>Options of value None are removed from generated JSON (e.g. from List or Map)</li> 
   <li>Default parameters are not supported at this time</li> 
   <li>Primitive/Simple Data types supported: 
    <ul> 
     <li>Int</li> 
     <li>Boolean</li> 
     <li>Long</li> 
     <li>Char</li> 
     <li>Double</li> 
     <li>Float</li> 
     <li>String</li> 
     <li>Byte</li> 
     <li>Short</li> 
     <li>java.util.UUID</li> 
     <li>org.joda.time.DateTime</li> 
     <li>Enumeration.Value</li> 
     <li>Value Class</li> 
    </ul></li> 
   <li>Collections supported: 
    <ul> 
     <li>scala.Option</li> 
     <li>scala.collection.immutable.List</li> 
     <li>scala.collection.immutable.Map</li> 
     <li>scala.collection.immutable.Set</li> 
     <li>scala.collection.immutable.HashMap</li> 
     <li>scala.collection.immutable.HashSet</li> 
     <li>scala.collection.immutable.ListMap</li> 
     <li>scala.collection.immutable.ListSet</li> 
     <li>scala.collection.immutable.Queue</li> 
     <li>scala.collection.immutable.Seq</li> 
     <li>scala.collection.immutable.Vector</li> 
     <li>scala.collection.mutable.ArrayBuffer</li> 
     <li>scala.collection.mutable.ArraySeq</li> 
     <li>scala.collection.mutable.HashMap</li> 
     <li>scala.collection.mutable.HashSet</li> 
     <li>scala.collection.mutable.IndexedSeq</li> 
     <li>scala.collection.mutable.LinearSeq</li> 
     <li>scala.collection.mutable.LinkedHashMap</li> 
     <li>scala.collection.mutable.LinkedHashSeq</li> 
     <li>scala.collection.mutable.ListBuffer</li> 
     <li>scala.collection.mutable.ListMap</li> 
     <li>scala.collection.mutable.Map</li> 
     <li>scala.collection.mutable.MutableList</li> 
     <li>scala.collection.mutable.OpenHashMap</li> 
     <li>scala.collection.mutable.Queue</li> 
     <li>scala.collection.mutable.ResizableArray</li> 
     <li>scala.collection.mutable.Seq</li> 
     <li>scala.collection.mutable.Set</li> 
     <li>scala.collection.mutable.Stack</li> 
     <li>scala.collection.mutable.WeakHashMap</li> 
    </ul></li> 
  </ul> 
  <p><strong>New for v4.3!</strong> Limited support of Any type is supported. You can use primitives, Lists[Any], Maps[String,Any], and nested List/Map with Any. Don't get too cute, though. Type inference is pretty primal and limited to a few basic types: String, Int, Double, Boolean, and null. See v4/AnyTests.scala for examples.</p> 
  <h1><a id="user-content-why" class="anchor" href="https://github.com/gzoller/scalajack#why" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Why?</h1> 
  <p>The natual and expected question when developing a library for a function that already exists in the marketplace is "Why?". Jackson has its own Scala module, and there is also a wonderful library called Salat that I've been using for years that does JSON parsing for Scala. What does ScalaJack offer these two don't?</p> 
  <p>Salat is very full-featured. It gives you a high level of control over the parsing process including custom serializers for non-standard types. Unlike a lot of JSON parsers that require "helper" code, and/or lots of annotations, Salat introspects Scala case classes and does it all almost completely automatically.</p> 
  <p>After using Salat for a long time I began to be curious how its performance stacked up against other JSON parsers. (In complete fairness, Salat's JSON handling features evolved some time after its primary mission of MongoDB DAO access.) I discovered Jackson's relatively new Scala module and found it blazing fast, but... I didn't like the way Enumeration and Option types were handled. It also didn't handle traits that I could see (serializing Dog and Cat, where both are a case classes extending trait Animal, and the parser can sort them out). It was configurable enough--but required a lot of manual fidgeting with annotations and such.</p> 
  <p>ScalaJack aimed for Jackson's speed and at least the key parts of Salat's seamless case class handling. ScalaJack is indeed faster than Salat (about twice as fast!) but losing nearly all of Salat's configurability. It does handle traits w/type hints seamlessly. Unlike Salat (at the time of this writing) ScalaJack also supports arbitrary nesting of data structures to allow you to construct sophisticated data structures with ease.</p> 
  <p>If you're OK with gatining lots of speed at the price of my assumptions, ScalaJack is a great thing!</p> 
  <p>Blcke</p> 
 </article>
</div>