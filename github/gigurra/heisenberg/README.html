<div class="announce instapaper_body md" data-path="README.md" id="readme">
 <article class="markdown-body entry-content" itemprop="text">
  <h1><a id="user-content-heisenberg" class="anchor" href="https://github.com/gigurra/heisenberg#heisenberg" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Heisenberg</h1> 
  <p>A scala library for handling dynamic and evolving [key,value] data when you're uncertain about its model, if there is no model, or you just don't care.</p> 
  <h2><a id="user-content-heisenberg-makes-dynamic-data-easier-to-manage" class="anchor" href="https://github.com/gigurra/heisenberg#heisenberg-makes-dynamic-data-easier-to-manage" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Heisenberg makes dynamic data easier to manage</h2> 
  <p>Think of your standard data&lt;-&gt;OO mapper, but with:</p> 
  <ul> 
   <li>Selective mapping without truncating source data</li> 
   <li>Fields of inconsistent types (e.g. x.a sometimes int, sometimes string)</li> 
   <li>Automatic data migration (field name changes, semantic changes etc.)</li> 
   <li><a href="https://twitter.github.io/scala_school/advanced-types.html" target="_blank">Type classes</a> instead of reflection</li> 
   <li>No macros, annotations or code generation (just pure Scala)</li> 
   <li>Custom arbitrary data validation (self-contained)</li> 
   <li>Seamless transitions between static and dynamic data</li> 
   <li>Custom types &amp; representations</li> 
   <li>Simple API</li> 
  </ul> 
  <h2><a id="user-content-compatibility" class="anchor" href="https://github.com/gigurra/heisenberg#compatibility" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Compatibility</h2> 
  <ul> 
   <li>Json (e.g. json4s, ..)</li> 
   <li>Schemaless NoSql databases (e.g. mongodb, couchbase, ..)</li> 
   <li>Any Key-Value data, really.. 
    <ul> 
     <li>currently anything that can be viewed as Map[String, Any]</li> 
    </ul></li> 
  </ul> 
  <h2><a id="user-content-misc" class="anchor" href="https://github.com/gigurra/heisenberg#misc" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Misc</h2> 
  <ul> 
   <li>Used by <a href="https://github.com/saiaku-gaming/valhalla-server" target="_blank">valhalla-game backend</a> (mongodb&lt;-&gt;[finagle + franklin + heisenerg]&lt;-&gt;unreal-engine) 
    <ul> 
     <li>This is where the heisenberg project started</li> 
    </ul></li> 
   <li>For more ideas on how to use Heisenberg check out: 
    <ul> 
     <li><a href="https://github.com/GiGurra/franklin" target="_blank">Franklin</a></li> 
     <li><a href="https://github.com/GiGurra/franklin-heisenberg-bridge" target="_blank">Franklin-Heisenberg-bridge</a></li> 
    </ul></li> 
   <li>Heisenberg is very much WIP.. Examples &amp; doc pending. 
    <ul> 
     <li>All suggestions appreciated</li> 
     <li>Yet to decide on API design and what features should/not be included</li> 
    </ul></li> 
  </ul> 
  <h2><a id="user-content-examples" class="anchor" href="https://github.com/gigurra/heisenberg#examples" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Examples</h2> 
  <p>Below are some simple examples showing how to use Heisenberg</p> 
  <h3><a id="user-content-parsing-dynamic-data" class="anchor" href="https://github.com/gigurra/heisenberg#parsing-dynamic-data" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Parsing dynamic data</h3> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">data</span> <span class="pl-k">=</span> <span class="pl-en">Map</span>(<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>lalala<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-c1">123</span>, <span class="pl-s"><span class="pl-pds">"</span>extra_data<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-en">Seq</span>(<span class="pl-c1">2</span>,<span class="pl-c1">3</span>,<span class="pl-c1">4</span>))

<span class="pl-k">object</span> <span class="pl-en">MyType</span> <span class="pl-k">extends</span> <span class="pl-e">Schema</span>[<span class="pl-en">MyType</span>] {
 <span class="pl-k">val</span> <span class="pl-en">foo</span> <span class="pl-k">=</span> required[<span class="pl-k">String</span>](<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>, default <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>foo_default<span class="pl-pds">"</span></span>)
 <span class="pl-k">val</span> <span class="pl-en">bar</span> <span class="pl-k">=</span> optional[<span class="pl-k">Int</span>](<span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>)
}

<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">MyType</span> (<span class="pl-v">source</span>: <span class="pl-en">Map</span>[<span class="pl-k">String</span>, <span class="pl-en">Any</span>]) <span class="pl-k">extends</span> <span class="pl-e">Parsed</span>[<span class="pl-en">MyType</span>.type] {
 <span class="pl-k">val</span> <span class="pl-en">foo</span><span class="pl-k">:</span> <span class="pl-k">String</span> <span class="pl-k">=</span> parse(schema.foo)
 <span class="pl-k">val</span> <span class="pl-en">bar</span><span class="pl-k">:</span> <span class="pl-en">Option</span>[<span class="pl-k">Int</span>] <span class="pl-k">=</span> parse(schema.bar)

 <span class="pl-c">// Example constraint</span>
 require(bar.forall(_ <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>), <span class="pl-s"><span class="pl-pds">"</span>bar must be positive<span class="pl-pds">"</span></span>)
}

<span class="pl-k">val</span> <span class="pl-en">instance</span><span class="pl-k">:</span> <span class="pl-en">MyType</span> <span class="pl-k">=</span> <span class="pl-en">MyType</span>.parse(data)
</pre>
  </div> 
  <h3><a id="user-content-producing-dynamic-data" class="anchor" href="https://github.com/gigurra/heisenberg#producing-dynamic-data" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Producing dynamic data</h3> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">data</span> <span class="pl-k">=</span> <span class="pl-en">Map</span>(<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>lalala<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-c1">123</span>, <span class="pl-s"><span class="pl-pds">"</span>extra_data<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-en">Seq</span>(<span class="pl-c1">2</span>,<span class="pl-c1">3</span>,<span class="pl-c1">4</span>))

<span class="pl-c">// The same as above</span>
<span class="pl-k">object</span> <span class="pl-en">MyType</span> ..
<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">MyType</span> ..
<span class="pl-k">val</span> <span class="pl-en">instance</span> ..

<span class="pl-c">// Including all the source data + default values for missing fields</span>
<span class="pl-k">val</span> <span class="pl-en">dataBack</span> <span class="pl-k">=</span> instance.flatten <span class="pl-c">// Map[String, Any]</span>

<span class="pl-c">// assuming we haven't added anything through e.g. default values:</span>
assert(data <span class="pl-k">==</span> databack)

</pre>
  </div> 
  <h3><a id="user-content-nested-types" class="anchor" href="https://github.com/gigurra/heisenberg#nested-types" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Nested types</h3> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">object</span> <span class="pl-en">MyRoot</span> <span class="pl-k">extends</span> <span class="pl-e">Schema</span>[<span class="pl-en">MyRoot</span>] {
 <span class="pl-k">val</span> <span class="pl-en">foo</span> <span class="pl-k">=</span> required[<span class="pl-en">Map</span>[<span class="pl-k">String</span>, <span class="pl-en">Seq</span>[<span class="pl-en">MyInner</span>]]](<span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>)
}
<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">MyRoot</span> (<span class="pl-v">source</span>: <span class="pl-en">Map</span>[<span class="pl-k">String</span>, <span class="pl-en">Any</span>]) <span class="pl-k">extends</span> <span class="pl-e">Parsed</span>[<span class="pl-en">MyRoot</span>.type] {
 <span class="pl-k">val</span> <span class="pl-en">foo</span> <span class="pl-k">=</span> parse(schema.foo)
}

<span class="pl-c">// Declaring your other class in the same way ..</span>
<span class="pl-k">object</span> <span class="pl-en">MyInner</span> ..
<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">MyInner</span> ..
</pre>
  </div> 
  <h3><a id="user-content-constructors" class="anchor" href="https://github.com/gigurra/heisenberg#constructors" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>'Constructors'</h3> 
  <p>While writing tests or if you wish to use Parsed subclasses as your application's inner types, writing maps and then parsing them can be rather cumbersome. The best way to get around this is to add some constructors. Either the traditional way directly to your classes or with the pattern seen below on their schemas (=companion objects):</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">object</span> <span class="pl-en">MyType</span> <span class="pl-k">extends</span> <span class="pl-e">Schema</span>[<span class="pl-en">MyType</span>] {
 <span class="pl-k">val</span> <span class="pl-en">foo</span> <span class="pl-k">=</span> required[<span class="pl-k">String</span>](<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>, default <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>foo_default<span class="pl-pds">"</span></span>) <span class="pl-c">// Creates a Field of type String</span>
 <span class="pl-k">val</span> <span class="pl-en">bar</span> <span class="pl-k">=</span> optional[<span class="pl-k">Int</span>](<span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>) <span class="pl-c">// Creates a Field of type Int</span>

 <span class="pl-k">def</span> <span class="pl-en">apply</span>(<span class="pl-v">foo</span>: <span class="pl-k">String</span>, 
           <span class="pl-v">bar</span>: <span class="pl-en">Option</span>[<span class="pl-k">Int</span>] <span class="pl-k">=</span> <span class="pl-c1">None</span>, 
           <span class="pl-v">extraData</span>: <span class="pl-en">Map</span>[<span class="pl-k">String</span>, <span class="pl-en">Any</span>] <span class="pl-k">=</span> <span class="pl-en">Map</span>.empty)<span class="pl-k">:</span> <span class="pl-en">MyType</span> <span class="pl-k">=</span> marshal (
   <span class="pl-v">this</span>.foo <span class="pl-k">-</span><span class="pl-k">&gt;</span> foo,
   <span class="pl-v">this</span>.bar <span class="pl-k">-</span><span class="pl-k">&gt;</span> bar,
   extraData
  )
}
</pre>
  </div> 
  <p>See classes 'MapData' and 'Parsed' for more information on this API.</p> 
  <h3><a id="user-content-type-composition" class="anchor" href="https://github.com/gigurra/heisenberg#type-composition" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Type composition</h3> 
  <p>Suppose you wish to partially share capabilities, fields, constraints etc between different types while sticking to DRY. Heisenberg supports mixins of components and component schemas. Below is an example taken from an early version of the Valhalla Game model.</p> 
  <p>The Heisenberg types in this example are:</p> 
  <ul> 
   <li>Character (A character with owner stored in mongodb)</li> 
   <li>SaveCharacter (A save character request received from unreal engine through finagle)</li> 
  </ul> 
  <p>They are almost identical, except that the type 'Character' contains an additional field 'owner' (see below).</p> 
  <div class="highlight highlight-source-scala">
   <pre>
<span class="pl-c">/////////////////////////////</span>
<span class="pl-c">// Our storage definition</span>

<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Character</span> (<span class="pl-v">source</span>: <span class="pl-en">Map</span>[<span class="pl-k">String</span>, <span class="pl-en">Any</span>])
  <span class="pl-k">extends</span> <span class="pl-e">Parsed</span>[<span class="pl-en">Character</span>.type]
  <span class="pl-k">with</span> <span class="pl-e">CharacterData</span>
  <span class="pl-k">with</span> <span class="pl-e">CharacterOwner</span> {
}

<span class="pl-k">object</span> <span class="pl-en">Character</span>
  <span class="pl-k">extends</span> <span class="pl-e">Schema</span>[<span class="pl-en">Character</span>]
  <span class="pl-k">with</span> <span class="pl-e">CharacterDataSchema</span>
  <span class="pl-k">with</span> <span class="pl-e">CharacterOwnerSchema</span> {

  <span class="pl-k">def</span> <span class="pl-en">apply</span>(<span class="pl-v">name</span>: <span class="pl-k">String</span>,
            <span class="pl-v">owner</span>: <span class="pl-k">String</span>,
            <span class="pl-v">inventory</span>: <span class="pl-en">Seq</span>[<span class="pl-en">Item</span>],
            <span class="pl-v">itemSlots</span>: <span class="pl-en">ItemSlots</span>,
            <span class="pl-v">skills</span>: <span class="pl-en">Seq</span>[<span class="pl-en">Skill</span>],
            <span class="pl-v">mesh</span>: <span class="pl-en">Mesh</span>) <span class="pl-k">=</span> marshal(
    <span class="pl-v">this</span>.name <span class="pl-k">-</span><span class="pl-k">&gt;</span> name,
    <span class="pl-v">this</span>.owner <span class="pl-k">-</span><span class="pl-k">&gt;</span> owner,
    <span class="pl-v">this</span>.inventory <span class="pl-k">-</span><span class="pl-k">&gt;</span> inventory,
    <span class="pl-v">this</span>.itemSlots <span class="pl-k">-</span><span class="pl-k">&gt;</span> itemSlots,
    <span class="pl-v">this</span>.skills <span class="pl-k">-</span><span class="pl-k">&gt;</span> skills,
    <span class="pl-v">this</span>.mesh <span class="pl-k">-</span><span class="pl-k">&gt;</span> mesh
  )
}


<span class="pl-c">/////////////////////////////</span>
<span class="pl-c">// Our message definition</span>

<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">SaveCharacter</span> (<span class="pl-v">source</span>: <span class="pl-en">Map</span>[<span class="pl-k">String</span>, <span class="pl-en">Any</span>])
  <span class="pl-k">extends</span> <span class="pl-e">Parsed</span>[<span class="pl-en">SaveCharacter</span>.type]
  <span class="pl-k">with</span> <span class="pl-e">CharacterData</span> {
}
<span class="pl-k">object</span> <span class="pl-en">SaveCharacter</span>
  <span class="pl-k">extends</span> <span class="pl-e">Schema</span>[<span class="pl-en">SaveCharacter</span>]
  <span class="pl-k">with</span> <span class="pl-e">CharacterDataSchema</span>


<span class="pl-c">/////////////////////////////</span>
<span class="pl-c">// Our components and schemas</span>

<span class="pl-k">trait</span> <span class="pl-en">CharacterData</span> <span class="pl-k">extends</span> <span class="pl-e">Component</span> {
  <span class="pl-k">def</span> <span class="pl-en">schema</span><span class="pl-k">:</span> <span class="pl-en">CharacterDataSchema</span>
  <span class="pl-k">val</span> <span class="pl-en">name</span> <span class="pl-k">=</span> parse(schema.name)
  <span class="pl-k">val</span> <span class="pl-en">inventory</span> <span class="pl-k">=</span> parse(schema.inventory)
  <span class="pl-k">val</span> <span class="pl-en">itemSlots</span> <span class="pl-k">=</span> parse(schema.itemSlots)
  <span class="pl-k">val</span> <span class="pl-en">skills</span> <span class="pl-k">=</span> parse(schema.skills)
  <span class="pl-k">val</span> <span class="pl-en">mesh</span> <span class="pl-k">=</span> parse(schema.mesh)
}

<span class="pl-k">trait</span> <span class="pl-en">CharacterOwner</span> <span class="pl-k">extends</span> <span class="pl-e">Component</span> {
  <span class="pl-k">def</span> <span class="pl-en">schema</span><span class="pl-k">:</span> <span class="pl-en">CharacterOwnerSchema</span>
  <span class="pl-k">val</span> <span class="pl-en">owner</span> <span class="pl-k">=</span> parse(schema.owner)
}

<span class="pl-k">trait</span> <span class="pl-en">CharacterDataSchema</span> <span class="pl-k">extends</span> <span class="pl-e">ComponentSchema</span> {
  <span class="pl-k">val</span> <span class="pl-en">name</span> <span class="pl-k">=</span> required[<span class="pl-k">String</span>](<span class="pl-s"><span class="pl-pds">"</span>name<span class="pl-pds">"</span></span>)
  <span class="pl-k">val</span> <span class="pl-en">inventory</span> <span class="pl-k">=</span> required[<span class="pl-en">Seq</span>[<span class="pl-en">Item</span>]](<span class="pl-s"><span class="pl-pds">"</span>inventory<span class="pl-pds">"</span></span>)
  <span class="pl-k">val</span> <span class="pl-en">itemSlots</span> <span class="pl-k">=</span> required[<span class="pl-en">ItemSlots</span>](<span class="pl-s"><span class="pl-pds">"</span>item_slots<span class="pl-pds">"</span></span>)
  <span class="pl-k">val</span> <span class="pl-en">skills</span> <span class="pl-k">=</span> required[<span class="pl-en">Seq</span>[<span class="pl-en">Skill</span>]](<span class="pl-s"><span class="pl-pds">"</span>skills<span class="pl-pds">"</span></span>)
  <span class="pl-k">val</span> <span class="pl-en">mesh</span> <span class="pl-k">=</span> required[<span class="pl-en">Mesh</span>](<span class="pl-s"><span class="pl-pds">"</span>mesh<span class="pl-pds">"</span></span>)
}

<span class="pl-k">trait</span> <span class="pl-en">CharacterOwnerSchema</span> <span class="pl-k">extends</span> <span class="pl-e">ComponentSchema</span> {
  <span class="pl-k">val</span> <span class="pl-en">owner</span> <span class="pl-k">=</span> required[<span class="pl-k">String</span>](<span class="pl-s"><span class="pl-pds">"</span>owner<span class="pl-pds">"</span></span>)
}

</pre>
  </div> 
  <p>It's a matter of taste if you prefer mixing in components or just having the Character class above store a SaveCharacter object + an owner field. I prefer component mixins - Heisenberg will let you do either.</p> 
  <p>A word on traditional OO inheritance: </p> 
  <ul> 
   <li>Heisenberg does not (yet) support inheritance 
    <ul> 
     <li>So stick to mixins/components for now</li> 
     <li>(although inheritance probably works with Heisenberg.. ;) it's not officially supported).</li> 
    </ul></li> 
  </ul> 
  <h3><a id="user-content-type-migration" class="anchor" href="https://github.com/gigurra/heisenberg#type-migration" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Type migration</h3> 
  <p>Each Heisenberg schema comes with an automatically created parser (Map[String, Any] =&gt; MyObjectType) - This parser is called when you call .parse(..) - as in the examples above. </p> 
  <p>It is possible to override this parser field in your Schemas. For migration purposes this can be a parser which handles more than one object type - i.e. a parser that first tries to parse =&gt; MyNewObjectType, and if that fails, tries to parse =&gt; MyOldObjectType and transforms the result to a MyNewObjectType. For this to work we need:</p> 
  <ul> 
   <li>MyNewObjectType.defaultParser</li> 
   <li>MyOldObjectType.parser</li> 
   <li>Your data transformation, 'migrator': [MyOldObjectType] =&gt; [MyNewObjectType]</li> 
  </ul> 
  <p>We then simply override the 'parser' field in our Schema, e.g:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">object</span> <span class="pl-en">MyNewObjectType</span> <span class="pl-k">extends</span> <span class="pl-e">Schema</span>[<span class="pl-en">MyNewObjectType</span>] {
 <span class="pl-k">def</span> <span class="pl-en">myMigration</span>(<span class="pl-v">old</span>: <span class="pl-en">MyOldObjectType</span>)<span class="pl-k">:</span> <span class="pl-en">MyNewObjectType</span> <span class="pl-k">=</span> {
  .. <span class="pl-c">// Your custom migration code : </span>
  .. <span class="pl-c">// MyOldObjectType =&gt; MyNewObjectType (See tests for examples)</span>
 }
 <span class="pl-k">override</span> <span class="pl-k">val</span> <span class="pl-en">parser</span> <span class="pl-k">=</span> <span class="pl-en">Migration</span>.parser(<span class="pl-en">MyNewObjectType</span>.defaultParser, <span class="pl-en">MyOldObjectType</span>.parser, myMigration)
}
</pre>
  </div> 
  <p>Any old stored/received data to be atomatically migrated the next time it is parsed. If you don't want this automatic behaviour you can always do the above manually. This is of course only necessary if you make breaking changes to your model (e.g. change field names or semantics). </p> 
  <p>Simple schema changes like adding and removing non-required fields don't require migration, as long as you don't reuse the same field name for another data type. Basically expect the same behaviour as your standard serialization libraries รก la Protobuf/Thrift.</p> 
  <h3><a id="user-content-field-migration" class="anchor" href="https://github.com/gigurra/heisenberg#field-migration" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Field migration</h3> 
  <p>There are several approaches you can use for field migration. First though - is this really what you want? Field migration is like the poor man's replacement/hack for type migration. But if you want it anyway, you can do something like: </p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">object</span> <span class="pl-en">TestType</span> <span class="pl-k">extends</span> <span class="pl-e">Schema</span>[<span class="pl-en">TestType</span>] {
  <span class="pl-c">// Here we define both what the field is and what it used to be</span>
  <span class="pl-k">val</span> <span class="pl-en">field</span> <span class="pl-k">=</span> required[<span class="pl-k">Int</span>](<span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>)
  <span class="pl-k">val</span> <span class="pl-en">oldField</span> <span class="pl-k">=</span> required[<span class="pl-k">String</span>](<span class="pl-s"><span class="pl-pds">"</span>bar<span class="pl-pds">"</span></span>)
}

<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">TestType</span>(<span class="pl-v">source</span>: <span class="pl-en">Map</span>[<span class="pl-k">String</span>, <span class="pl-en">Any</span>]) <span class="pl-k">extends</span> <span class="pl-e">Parsed</span>[<span class="pl-en">TestType</span>.type] {
  <span class="pl-c">// Here we define how to transition from the old definition to the new</span>
  <span class="pl-k">val</span> <span class="pl-en">foo</span> <span class="pl-k">=</span> parse(schema.field, orElse <span class="pl-k">=</span> <span class="pl-c1">2</span> <span class="pl-k">*</span> parse(schema.oldField).toInt)
}</pre>
  </div> 
  <p>Suppose instead that the field changed type and semantics, but not name. Then you could do something like:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">object</span> <span class="pl-en">TestType</span> <span class="pl-k">extends</span> <span class="pl-e">Schema</span>[<span class="pl-en">TestType</span>] {
  <span class="pl-k">val</span> <span class="pl-en">foobar</span> <span class="pl-k">=</span> required[<span class="pl-en">Either</span>[<span class="pl-k">Int</span>, <span class="pl-k">String</span>]](<span class="pl-s"><span class="pl-pds">"</span>foobar<span class="pl-pds">"</span></span>)
}

<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">TestType</span>(<span class="pl-v">source</span>: <span class="pl-en">Map</span>[<span class="pl-k">String</span>, <span class="pl-en">Any</span>]) <span class="pl-k">extends</span> <span class="pl-e">Parsed</span>[<span class="pl-en">TestType</span>.type] {
  <span class="pl-k">val</span> <span class="pl-en">foobar</span> <span class="pl-k">:</span> <span class="pl-k">Int</span> <span class="pl-k">=</span> parse(schema.foobar) <span class="pl-k">match</span> {
                      <span class="pl-k">case</span> <span class="pl-en">Left</span>(int) <span class="pl-k">=&gt;</span> int
                      <span class="pl-k">case</span> <span class="pl-en">Right</span>(string) <span class="pl-k">=&gt;</span> <span class="pl-c1">2</span> <span class="pl-k">*</span> string.toInt
                     }
}</pre>
  </div> 
  <p>Or define two separate fields refering to the same field name, and apply the previous strategy.</p> 
  <h3><a id="user-content-custom-types" class="anchor" href="https://github.com/gigurra/heisenberg#custom-types" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Custom types</h3> 
  <p>Sometimes you will want add write non-heisenberg objects to your schemas - Heisenberg only requires a MapDataParser[T] and a MapDataProducer[T] to be available during compile time. As long as those two exist, you can add whatever types you want. Below is an example:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">object</span> <span class="pl-en">Event</span> <span class="pl-k">extends</span> <span class="pl-e">Schema</span>[<span class="pl-en">Event</span>] {
 <span class="pl-c">// to handle custom types, we must provide a producer and a parser. </span>
 <span class="pl-c">// Not doing so will cause the compilation to fail. (here: Instant = java.time.Instant)</span>
 <span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">iProducer</span> <span class="pl-k">=</span> (<span class="pl-v">t</span>: <span class="pl-en">Instant</span>) <span class="pl-k">=&gt;</span> i.toString <span class="pl-c">// Or expose an instance of the MapDataProducer[Instant] trait instead</span>
 <span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">iParser</span> <span class="pl-k">=</span> (<span class="pl-v">x</span>: <span class="pl-en">Any</span>) <span class="pl-k">=&gt;</span> x <span class="pl-k">match</span> { <span class="pl-c">// Or expose an instance of the MapDataParser[Instant] trait instead</span>
  <span class="pl-k">case</span> <span class="pl-v">x</span>: <span class="pl-k">String</span> <span class="pl-k">=&gt;</span> <span class="pl-en">Instant</span>.parse(x) <span class="pl-c">// iso timestamp string</span>
  <span class="pl-k">case</span> <span class="pl-v">x</span>: <span class="pl-en">Number</span> <span class="pl-k">=&gt;</span> <span class="pl-k">new</span> <span class="pl-en">Instant</span>(x, <span class="pl-c1">0</span>) <span class="pl-c">// epoch millis</span>
  <span class="pl-k">case</span> x <span class="pl-k">=&gt;</span> <span class="pl-k">throw</span> <span class="pl-en">MapDataParser</span>.<span class="pl-en">WrongType</span>(expect <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>String or Number for Instant<span class="pl-pds">"</span></span>, actual <span class="pl-k">=</span> x.getClass.toString)
 }

 <span class="pl-k">val</span> <span class="pl-en">timeStamp</span> <span class="pl-k">=</span> required[<span class="pl-en">Instant</span>](<span class="pl-s"><span class="pl-pds">"</span>log_time<span class="pl-pds">"</span></span>, default <span class="pl-k">=</span> <span class="pl-en">Instant</span>.now())
 <span class="pl-k">val</span> <span class="pl-en">content</span> <span class="pl-k">=</span> optional[<span class="pl-k">String</span>](<span class="pl-s"><span class="pl-pds">"</span>content<span class="pl-pds">"</span></span>)
}
<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Event</span> (<span class="pl-v">source</span>: <span class="pl-en">Map</span>[<span class="pl-k">String</span>, <span class="pl-en">Any</span>]) <span class="pl-k">extends</span> <span class="pl-e">Parsed</span>[<span class="pl-en">Event</span>.type] {
 <span class="pl-k">val</span> <span class="pl-en">timeStamp</span> <span class="pl-k">=</span> parse(schema.timeStamp)
 <span class="pl-k">val</span> <span class="pl-en">content</span> <span class="pl-k">=</span> parse(schema.content)
}
</pre>
  </div> 
  <h2><a id="user-content-default-supported-types" class="anchor" href="https://github.com/gigurra/heisenberg#default-supported-types" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Default supported types</h2> 
  <p>As seen in the examples above - you need to provide a parser and producer (<a href="https://twitter.github.io/scala_school/advanced-types.html" target="_blank">type classes</a> - implementing the traits MapDataProducer[T] and MapDataParser[T]) for every Custom type not supported by default. The following types (and any combination of them) are supported by default:</p> 
  <ul> 
   <li>fixed point numbers (Byte, Short, Int, Long, BigInt)</li> 
   <li>floating point numbers (Float, Double)</li> 
   <li>String</li> 
   <li>Boolean</li> 
   <li>Seq[T : MapDataProducer : MapDataParser]</li> 
   <li>Map[String, T : MapDataProducer : MapDataParser]</li> 
   <li>Set[T : MapDataProducer : MapDataParser]</li> 
   <li>Either[L: MapDataProducer : MapDataParser, R : MapDataProducer : MapDataParser]</li> 
   <li>Option[T : MapDataProducer : MapDataParser] 
    <ul> 
     <li>As above or the optional[T] schema keyword</li> 
    </ul></li> 
   <li>Subclasses of Parsed (as in the examples above)</li> 
  </ul> 
  <p>Parsers are instantiated at application load (As implicit Field parameters when your schemas are loaded by the classloader) and verified to exist in compile time. If you are missing one for your type - you will know when you compile your code.</p> 
  <p>You can always override the default parser on both field and type level.</p> 
  <h2><a id="user-content-what-about-performance" class="anchor" href="https://github.com/gigurra/heisenberg#what-about-performance" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>What about performance?</h2> 
  <ul> 
   <li><p>There's a lot of metadata here..</p> 
    <ul> 
     <li>I know - Heisenberg is young. We'll make it faster if it turns out to be slow</li> 
    </ul></li> 
   <li><p>Hey - you said no reflection!</p> 
    <ul> 
     <li>Heisenberg uses TypeTags to produce error messages. But it shouldn't impact happy path performance.</li> 
    </ul></li> 
  </ul> 
  <h2><a id="user-content-try-it" class="anchor" href="https://github.com/gigurra/heisenberg#try-it" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Try it</h2> 
  <p>Put a dependency in your build.sbt.</p> 
  <div class="highlight highlight-source-scala">
   <pre>libraryDependencies <span class="pl-k">+</span><span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>com.github.gigurra<span class="pl-pds">"</span></span> <span class="pl-k">%%</span> <span class="pl-s"><span class="pl-pds">"</span>heisenberg<span class="pl-pds">"</span></span> <span class="pl-k">%</span> <span class="pl-s"><span class="pl-pds">"</span>0.2.8<span class="pl-pds">"</span></span></pre>
  </div> 
  <h2><a id="user-content-etc" class="anchor" href="https://github.com/gigurra/heisenberg#etc" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Etc</h2> 
  <p>Heisenberg is built using <a href="https://twitter.github.io/scala_school/advanced-types.html" target="_blank">type classes</a> which specify how each type should be observed. Parsed objects are always accompanied by their source data (on any level of nesting), so no information is lost even though we only specify a subset of all actual fields.</p> 
  <p>Want to consolidate data of different models into a single one? Got data mixed from different application versions? Want to support multiple client application versions? Building a simple object persistence layer or routing service where only a subset of information needs to be parsed - <em>but the source data still needs to be kept intact</em>? - Why not give Heisenberg a chance :).</p> 
  <p>Got some FancyType that you don't want to rewrite for Heisenberg type but still want to mix in? Just provide a MapDataProducer[FancyType] and MapDataParser[FancyType] <a href="https://twitter.github.io/scala_school/advanced-types.html" target="_blank">type class</a> and you're good to go!</p> 
  <p>The name Heisenberg comes from uncertainty in the data, but also wanting to observe as little of the data as possible, so as to not constrain whoever has the real model/definition of the data and let them evolve their model freely. </p> 
  <p>There's no code generation in Heisenberg, but if you need it, it shouldn't be too hard to add in both directions (e.g. protobuf &lt;-&gt; heisenberg, heisenberg &lt;-&gt; cql statements etc.. You can probably do it on-the-fly, dynamically ;) )</p> 
  <p>May at some point leverage Shapeless and/or Scalaz, but for now is just plain-old-scala.</p> 
 </article>
</div>