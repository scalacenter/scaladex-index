<div class="announce instapaper_body md" data-path="README.md" id="readme">
 <article class="markdown-body entry-content" itemprop="text">
  <p><a href="https://travis-ci.org/non/spire/" target="_blank"><img src="https://camo.githubusercontent.com/56f72a40c4c2d372c725ac9d3d748467cf1b0a4d/68747470733a2f2f6170692e7472617669732d63692e6f72672f6e6f6e2f73706972652e706e67" alt="Build Status" data-canonical-src="https://api.travis-ci.org/non/spire.png" style="max-width:100%;"></a> <a href="https://gitter.im/non/spire?utm_source=badge&amp;utm_medium=badge&amp;utm_campaign=pr-badge&amp;utm_content=badge" target="_blank"><img src="https://camo.githubusercontent.com/da2edb525cde1455a622c58c0effc3a90b9a181c/68747470733a2f2f6261646765732e6769747465722e696d2f4a6f696e253230436861742e737667" alt="Gitter" data-canonical-src="https://badges.gitter.im/Join%20Chat.svg" style="max-width:100%;"></a> <a href="http://codecov.io/github/non/spire?branch=master" target="_blank"><img src="https://camo.githubusercontent.com/21fd994a579e24287a2231d0c08003273aaaf577/687474703a2f2f636f6465636f762e696f2f6769746875622f6e6f6e2f73706972652f636f7665726167652e7376673f6272616e63683d6d6173746572" alt="codecov.io" data-canonical-src="http://codecov.io/github/non/spire/coverage.svg?branch=master" style="max-width:100%;"></a> <a href="https://maven-badges.herokuapp.com/maven-central/org.spire-math/spire_2.11" target="_blank"><img src="https://camo.githubusercontent.com/a039fb60bb286b83f152ea563c6a31007cbd94c1/68747470733a2f2f6d6176656e2d6261646765732e6865726f6b756170702e636f6d2f6d6176656e2d63656e7472616c2f6f72672e73706972652d6d6174682f73706972655f322e31312f62616467652e737667" alt="Maven Central" data-canonical-src="https://maven-badges.herokuapp.com/maven-central/org.spire-math/spire_2.11/badge.svg" style="max-width:100%;"></a></p> 
  <h2><a id="user-content-spire" class="anchor" href="https://github.com/non/spire#spire" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Spire</h2> 
  <h3><a id="user-content-overview" class="anchor" href="https://github.com/non/spire#overview" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Overview</h3> 
  <p>Spire is a numeric library for Scala which is intended to be generic, fast, and precise.</p> 
  <p>Using features such as specialization, macros, type classes, and implicits, Spire works hard to defy conventional wisdom around performance and precision trade-offs. A major goal is to allow developers to write efficient numeric code without having to "bake in" particular numeric representations. In most cases, generic implementations using Spire's specialized type classes perform identically to corresponding direct implementations.</p> 
  <h3><a id="user-content-scaladoc" class="anchor" href="https://github.com/non/spire#scaladoc" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Scaladoc</h3> 
  <p><a href="http://javadoc-badge.appspot.com/org.spire-math/spire_2.11/index.html#spire.package" target="_blank"><img src="https://camo.githubusercontent.com/0c0acb90c065a9422ff5397c07d0f8a208199932/687474703a2f2f6a617661646f632d62616467652e61707073706f742e636f6d2f6f72672e73706972652d6d6174682f73706972655f322e31312e7376673f6c6162656c3d636f7265" alt="Core" data-canonical-src="http://javadoc-badge.appspot.com/org.spire-math/spire_2.11.svg?label=core" style="max-width:100%;"></a> <a href="http://javadoc-badge.appspot.com/org.spire-math/spire-extras_2.11" target="_blank"><img src="https://camo.githubusercontent.com/0dc2c01f1676572b1ea8423bfbe807a29b980f00/687474703a2f2f6a617661646f632d62616467652e61707073706f742e636f6d2f6f72672e73706972652d6d6174682f73706972652d6578747261735f322e31312e7376673f6c6162656c3d657874726173" alt="Extras" data-canonical-src="http://javadoc-badge.appspot.com/org.spire-math/spire-extras_2.11.svg?label=extras" style="max-width:100%;"></a> <a href="http://javadoc-badge.appspot.com/org.spire-math/spire-laws_2.11/index.html#spire.laws.package" target="_blank"><img src="https://camo.githubusercontent.com/0d4e5bc9fbebd78c0b83ba0b1b9eccac719e8191/687474703a2f2f6a617661646f632d62616467652e61707073706f742e636f6d2f6f72672e73706972652d6d6174682f73706972652d6c6177735f322e31312e7376673f6c6162656c3d6c617773" alt="Laws" data-canonical-src="http://javadoc-badge.appspot.com/org.spire-math/spire-laws_2.11.svg?label=laws" style="max-width:100%;"></a> <a href="http://javadoc-badge.appspot.com/org.spire-math/spire-macros_2.11/index.html#spire.macros.package" target="_blank"><img src="https://camo.githubusercontent.com/a57da11201b041c21aee7598d6de52e858232211/687474703a2f2f6a617661646f632d62616467652e61707073706f742e636f6d2f6f72672e73706972652d6d6174682f73706972652d6d6163726f735f322e31312e7376673f6c6162656c3d6d6163726f73" alt="Macros" data-canonical-src="http://javadoc-badge.appspot.com/org.spire-math/spire-macros_2.11.svg?label=macros" style="max-width:100%;"></a></p> 
  <p>Spire is provided to you as free software under the <a href="https://github.com/non/spire/blob/master/COPYING" target="_blank">MIT license</a>.</p> 
  <h3><a id="user-content-organization" class="anchor" href="https://github.com/non/spire#organization" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Organization</h3> 
  <p>The <a href="http://groups.google.com/group/typelevel/" target="_blank">Spire mailing list</a> is shared with other <a href="http://typelevel.org" target="_blank">Typelevel projects</a>. It is the place to go for announcements and discussions around Spire. When posting, place the word <code>[spire]</code> at the begining of your subject. We also have a guide on <a href="https://github.com/non/spire/blob/master/CONTRIBUTING.md" target="_blank">contributing to Spire</a> as well as a guide that provides information on <a href="https://github.com/non/spire/blob/master/GUIDE.md" target="_blank">Spire's design</a>.</p> 
  <p>Spire has maintainers who are responsible for signing-off on and merging pull requests, and for helping to guide the direction of Spire:</p> 
  <ul> 
   <li>Erik Osheim (<em><a href="mailto:erik@osheim.org" target="_blank">erik@osheim.org</a></em>)</li> 
   <li>Tom Switzer (<em><a href="mailto:thomas.switzer@gmail.com" target="_blank">thomas.switzer@gmail.com</a></em>)</li> 
   <li>Rüdiger Klaehn (<em><a href="mailto:rklaehn@gmail.com" target="_blank">rklaehn@gmail.com</a></em>)</li> 
   <li>Denis Rosset (<em><a href="mailto:denis.rosset@unige.ch" target="_blank">denis.rosset@unige.ch</a></em>)</li> 
  </ul> 
  <p>People are expected to follow the <a href="http://typelevel.org/conduct.html" target="_blank">Typelevel Code of Conduct</a> when discussing Spire on the Github page, in Gitter, the IRC channel, mailing list, and other official venues.</p> 
  <p>Concerns or issues can be sent to any of Spire's maintainers, or to the <a href="http://typelevel.org/about.html" target="_blank">Typelevel</a> organization.</p> 
  <h3><a id="user-content-set-up" class="anchor" href="https://github.com/non/spire#set-up" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Set up</h3> 
  <p>Spire is currently available for Scala 2.10 and 2.11 (and supports scala-js for both versions).</p> 
  <p>To get started with SBT, simply add the following to your <code>build.sbt</code> file:</p> 
  <pre><code>libraryDependencies += "org.spire-math" %% "spire" % "0.13.0"
</code></pre> 
  <p>For Maven instructions, and to download the jars directly, visit the <a href="http://search.maven.org/#artifactdetails%7Corg.spire-math%7Cspire_2.11%7C0.11.0%7Cjar" target="_blank">Central Maven repository</a>.</p> 
  <p>Here is a list of all of Spire's modules:</p> 
  <ul> 
   <li><code>spire-macros</code>: macros and compile-time code (required by <code>spire</code>)</li> 
   <li><code>spire</code>: the core Spire library, the types and type classes</li> 
   <li><code>spire-laws</code>: optional support for law-checking and testing</li> 
   <li><code>spire-extras</code>: extra types which are more specific or esoteric</li> 
  </ul> 
  <h3><a id="user-content-playing-around" class="anchor" href="https://github.com/non/spire#playing-around" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Playing Around</h3> 
  <p>If you clone the Spire repo, you can get a taste of what Spire can do using SBT's console. Launch <code>sbt</code> and at the prompt, type <code>coreJVM/console</code>:</p> 
  <pre><code>&gt; coreJVM/console
[info] Generating spire/std/tuples.scala
[info] Starting scala interpreter...
[info]
Welcome to Scala version 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_51).
Type in expressions to have them evaluated.
Type :help for more information.

scala&gt; import spire.implicits._
import spire.implicits._

scala&gt; import spire.math._
import spire.math._

scala&gt; Complex(3.0, 5.0).sin
res0: spire.math.Complex[Double] = (10.472508533940392 + -73.46062169567367i)
</code></pre> 
  <h3><a id="user-content-number-types" class="anchor" href="https://github.com/non/spire#number-types" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Number Types</h3> 
  <p>In addition to supporting all of Scala's built-in number types, Spire introduces several new ones, all of which can be found in <code>spire.math</code>:</p> 
  <ul> 
   <li><code>Natural</code> unsigned, immutable, arbitrary precision integer</li> 
   <li><code>Rational</code> fractions of integers with perfect precision</li> 
   <li><code>Algebraic</code> lazily-computed, arbitrary precision algebraic numbers</li> 
   <li><code>Real</code> computable real number implementation</li> 
   <li><code>Complex[A]</code> complex numbers, points on the complex plane</li> 
   <li><code>Jet[A]</code> N-dimensional dual numbers, for automatic differentiation</li> 
   <li><code>Quaternion[A]</code> extension of complex numbers into 4D space</li> 
   <li><code>UByte</code> through <code>ULong</code> value classes supporting unsigned operations</li> 
   <li><code>SafeLong</code> fast, overflow-proof integer type</li> 
   <li><code>Number</code> boxed type supporting a traditional numeric tower</li> 
   <li><code>Interval[A]</code> arithmetic on open, closed, and unbound intervals</li> 
   <li><code>Polynomial[A]</code> univariate (single-variable) polynomial expressions</li> 
   <li><code>Trilean</code> value class supporting three-valued logic</li> 
   <li><code>FixedPoint</code> fractions with <code>Long</code> numerator and implicit denominator (in <em>extras</em>)</li> 
  </ul> 
  <p>Detailed treatment of these types can be found in the <a href="https://github.com/non/spire/blob/master/GUIDE.md" target="_blank">guide</a>.</p> 
  <h3><a id="user-content-type-classes" class="anchor" href="https://github.com/non/spire#type-classes" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Type Classes</h3> 
  <p>Spire provides type classes to support a wide range of unary and binary operations on numbers. The type classes are specialized, do no boxing, and use implicits to provide convenient infix syntax.</p> 
  <p>The general-purpose type classes can be found in <code>spire.math</code> and consist of:</p> 
  <ul> 
   <li><code>Numeric[A]</code> all number types, makes "best effort" to support operators</li> 
   <li><code>Fractional[A]</code> fractional number types, where <code>/</code> is true division</li> 
   <li><code>Integral[A]</code> integral number types, where <code>/</code> is floor division</li> 
  </ul> 
  <p>Some of the general-purpose type classes are built in terms of a set of more fundamental type classes defined in <code>spire.algebra</code>. Many of these correspond to concepts from abstract algebra:</p> 
  <ul> 
   <li><code>Eq[A]</code> types that can be compared for equality</li> 
   <li><code>Order[A]</code> types that can be compared and ordered</li> 
   <li><code>PartialOrder[A]</code> types that can be compared for equality, and for which certain pairs are ordered</li> 
   <li><code>Semigroup[A]</code> types with an associative binary operator <code>|+|</code></li> 
   <li><code>Monoid[A]</code> semigroups that have an identity element</li> 
   <li><code>Group[A]</code> monoids that have an inverse operator</li> 
   <li><code>(Left/Right/)Action[P, G]</code> left/right/ actions of semigroups/monoids/groups</li> 
   <li><code>Semiring[A]</code> types that form semigroups under <code>+</code> and <code>*</code></li> 
   <li><code>Rng[A]</code> types that form a group under <code>+</code> and a semigroup under <code>*</code></li> 
   <li><code>Rig[A]</code> types that form monoids under <code>+</code> and <code>*</code></li> 
   <li><code>Ring[A]</code> types that form a group under <code>+</code> and a monoid under <code>*</code></li> 
   <li><code>EuclideanRing[A]</code> rings with quotients and remainders (euclidean division)</li> 
   <li><code>Field[A]</code> euclidean rings with multiplicative inverses (reciprocals)</li> 
   <li><code>Signed[A]</code> types that have a sign (negative, zero, positive)</li> 
   <li><code>NRoot[A]</code> types that support k-roots, logs, and fractional powers</li> 
   <li><code>Module[V,R]</code> types that form a left R-module</li> 
   <li><code>VectorSpace[V,F]</code> types that form a vector space</li> 
   <li><code>NormedVectorSpace[V,F]</code> types with an associated norm</li> 
   <li><code>InnerProductSpace[V,F]</code> types with an inner product</li> 
   <li><code>MetricSpace[V,R]</code> types with an associated metric</li> 
   <li><code>Trig[A]</code> types that support trigonometric functions</li> 
   <li><code>Bool[A]</code> types that form a Boolean algebra</li> 
   <li><code>Heyting[A]</code> types that form a Heyting algebra</li> 
  </ul> 
  <p>Variants of Semigroup/Monoid/Group/Action with partial operations are defined in the <code>spire.algebra.partial</code> subpackage.</p> 
  <p>In addition to the type classes themselves, <code>spire.implicits</code> defines many implicits which provide unary and infix operators for the type classes. The easiest way to use these is via a wildcard import of <code>spire.implicits._</code>.</p> 
  <p>Detailed treatment of these type classes can be found in the <a href="https://github.com/non/spire/blob/master/GUIDE.md" target="_blank">guide</a>.</p> 
  <h3><a id="user-content-getting-started" class="anchor" href="https://github.com/non/spire#getting-started" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Getting Started</h3> 
  <p>Spire contains a lot of types, as well as other machinery to provide a nice user experience. The easiest way to use spire is via wildcard imports:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">spire.algebra.</span><span class="pl-v">_   </span><span class="pl-c"><span class="pl-c">//</span> provides algebraic type classes</span>
<span class="pl-k">import</span> <span class="pl-v">spire.math.</span><span class="pl-v">_      </span><span class="pl-c"><span class="pl-c">//</span> provides functions, types, and type classes</span>
<span class="pl-k">import</span> <span class="pl-v">spire.implicits.</span><span class="pl-v">_ </span><span class="pl-c"><span class="pl-c">//</span> provides infix operators, instances and conversions</span></pre>
  </div> 
  <p>Of course, you can still productively use Spire without wildcard imports, but it may require a bit more work to figure out which functionality you want and where it's coming from.</p> 
  <h3><a id="user-content-operators-by-type-class" class="anchor" href="https://github.com/non/spire#operators-by-type-class" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Operators by Type Class</h3> 
  <p>The following is an outline in more detail of the type classes provided by Spire, as well as the operators that they use. While Spire avoids introducing novel operators when possible, in a few cases it was unavoidable.</p> 
  <h4><a id="user-content-eq-order-and-partialorder" class="anchor" href="https://github.com/non/spire#eq-order-and-partialorder" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Eq, Order and PartialOrder</h4> 
  <p>The type classes provide type-safe equivalence and comparison functions. Orderings can be total (<code>Order</code>) or partial (<code>PartialOrder</code>); although undefined elements like <code>NaN</code> or <code>null</code> will cause problems in the default implementations [1].</p> 
  <ul> 
   <li><em>Eq</em> 
    <ul> 
     <li>eqv (<code>===</code>): equivalence</li> 
     <li>neqv (<code>=!=</code>): non-equivalence</li> 
    </ul></li> 
   <li><em>Order</em> 
    <ul> 
     <li>compare: less-than (-1), equivalent (0), or greater-than (1)</li> 
     <li>gt (<code>&gt;</code>): greater-than</li> 
     <li>gteqv (<code>&gt;=</code>): greater-than-or-equivalent</li> 
     <li>lt (<code>&lt;</code>): less-than</li> 
     <li>lteqv (<code>&lt;=</code>): less-than-or-equivalent</li> 
     <li>min: find least value</li> 
     <li>max: find greatest value</li> 
    </ul></li> 
   <li><em>PartialOrder</em> 
    <ul> 
     <li>partialCompare: less-than (<code>-1.0</code>), equivalent (<code>0.0</code>), greater-than (<code>1.0</code>) or incomparable (<code>NaN</code>)</li> 
     <li>tryCompare: less-than (<code>Some(-1)</code>), equivalent (<code>Some(0)</code>), greater-than (<code>Some(1)</code>) or incomparable (<code>None</code>)</li> 
     <li>pmin: find the least value if the elements are comparable; returns an <code>Option</code></li> 
     <li>pmax: find the greated value if the elements are comparable; returns an <code>Option</code></li> 
     <li>gt (<code>&gt;</code>), gteqv (<code>&gt;=</code>), lt (<code>&lt;</code>) and lteqv (<code>&lt;=</code>) return false if the elements are incomparable, or the result of their comparison</li> 
    </ul></li> 
  </ul> 
  <p>[1] For floating-point numbers, alternate implementations that take <code>NaN</code> into account can be imported from <code>spire.optional.totalfloat._</code>.</p> 
  <h4><a id="user-content-semigroup-monoid-and-group" class="anchor" href="https://github.com/non/spire#semigroup-monoid-and-group" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Semigroup, Monoid, and Group</h4> 
  <p>These general type classes constitute very general operations. The operations range from addition and multiplication to concatenating strings or lists, and beyond!</p> 
  <ul> 
   <li><em>Semigroup</em> 
    <ul> 
     <li>op (<code>|+|</code>): associative binary operator</li> 
    </ul></li> 
   <li><em>Monoid</em> 
    <ul> 
     <li>id: an identity element</li> 
     <li>isId: checks (together with Eq) for identity</li> 
    </ul></li> 
   <li><em>Group</em> 
    <ul> 
     <li>inverse: an unary operator</li> 
    </ul></li> 
  </ul> 
  <p>There are Additive and Multiplicative refinements of these general type classes, which are used in the Ring-family of type classes.</p> 
  <h4><a id="user-content-rings-co" class="anchor" href="https://github.com/non/spire#rings-co" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Rings &amp;co</h4> 
  <p>The Ring family of type classes provides the typical arithmetic operations most users will expect.</p> 
  <ul> 
   <li><em>Semiring</em> 
    <ul> 
     <li>plus (<code>+</code>): addition</li> 
     <li>times (<code>*</code>): multiplication</li> 
     <li>pow (<code>**</code>): exponentiation (integral exponent)</li> 
    </ul></li> 
   <li><em>Rng</em> 
    <ul> 
     <li>negate (<code>-</code>): additive inverse</li> 
     <li>minus (<code>-</code>): subtraction</li> 
     <li>zero: additive identity</li> 
    </ul></li> 
   <li><em>Rig</em> 
    <ul> 
     <li>zero: additive identity</li> 
     <li>one: multiplicative identity</li> 
    </ul></li> 
   <li><em>Ring</em> (Rng + Rig)</li> 
   <li><em>EuclideanRing</em> 
    <ul> 
     <li>quot (<code>/~</code>): quotient (floor division)</li> 
     <li>mod (<code>%</code>): remainder</li> 
     <li>quotmod (<code>/%</code>): quotient and mod</li> 
     <li>gcd: greatest-common-divisor</li> 
     <li>lcm: least-common-multiple</li> 
    </ul></li> 
   <li><em>Field</em> 
    <ul> 
     <li>reciprocal: multiplicative inverse</li> 
     <li>div (<code>/</code>): division</li> 
     <li>ceil: round up</li> 
     <li>floor: round down</li> 
     <li>round: round to nearest</li> 
    </ul></li> 
   <li><em>NRoot</em> 
    <ul> 
     <li>nroot: k-roots (k: Int)</li> 
     <li>sqrt: square root</li> 
     <li>log: natural logarithm</li> 
     <li>fpow (<code>**</code>): exponentiation (fractional exponent)</li> 
    </ul></li> 
  </ul> 
  <h4><a id="user-content-vectorspaces-co" class="anchor" href="https://github.com/non/spire#vectorspaces-co" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>VectorSpaces &amp;co</h4> 
  <p>The vector space family of type classes provide basic vector operations. They are parameterized on 2 types: the vector type and the scalar type.</p> 
  <ul> 
   <li><em>Module</em> 
    <ul> 
     <li>plus (<code>+</code>): vector addition</li> 
     <li>minus (<code>-</code>): vector subtraction</li> 
     <li>timesl (<code>*:</code>): scalar multiplication</li> 
    </ul></li> 
   <li><em>VectorSpace</em> 
    <ul> 
     <li>divr (<code>:/</code>): scalar division</li> 
    </ul></li> 
   <li><em>NormedVectorSpace</em> 
    <ul> 
     <li>norm: vector norm</li> 
     <li>normalize: normalizes vector (so norm is 1)</li> 
    </ul></li> 
   <li><em>InnerProductSpace</em> 
    <ul> 
     <li>dot (<code>⋅</code>, <code>dot</code>): vector inner product</li> 
    </ul></li> 
  </ul> 
  <h4><a id="user-content-numeric-integral-and-fractional" class="anchor" href="https://github.com/non/spire#numeric-integral-and-fractional" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Numeric, Integral, and Fractional</h4> 
  <p>These high-level type classes will pull in all of the relevant algebraic type classes. Users who aren't concerned with algebraic properties directly, or who wish for more permissiveness, should prefer these type classes.</p> 
  <ul> 
   <li><em>Integral</em>: whole number types (e.g. <code>Int</code>, <code>BigInt</code>)</li> 
   <li><em>Fractional</em>: fractional/decimal types (e.g. <code>Double</code>, <code>Rational</code>)</li> 
   <li><em>Numeric</em>: any number type, making "best effort" to support ops</li> 
  </ul> 
  <p>The <code>Numeric</code> type class is unique in that it provides the same functionality as <code>Fractional</code> for all number types. Each type will attempt to "do the right thing" as far as possible, and throw errors otherwise. Users who are leery of this behavior are encouraged to use more precise type classes.</p> 
  <h4><a id="user-content-bool" class="anchor" href="https://github.com/non/spire#bool" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Bool</h4> 
  <p>Bool supports Boolean algebras, an abstraction of the familiar bitwise boolean operators.</p> 
  <ul> 
   <li><em>Bool</em> 
    <ul> 
     <li>complement (unary <code>~</code>): logical negation</li> 
     <li>and (<code>&amp;</code>): conjunction</li> 
     <li>or (<code>|</code>): disjunction</li> 
     <li>xor (<code>^</code>): exclusive-disjunction</li> 
     <li>imp: implicitation, equivalent to <code>~a | b</code></li> 
     <li>nand: "not-and," equivalent to <code>~(a &amp; b)</code></li> 
     <li>nor: "not-or," equivalent to <code>~(a | b)</code></li> 
     <li>nxor: "not-xor," equivalent to <code>~(a ^ b)</code></li> 
    </ul></li> 
  </ul> 
  <p>Bool instances exist not just for <code>Boolean</code>, but also for <code>Byte</code>, <code>Short</code>, <code>Int</code>, <code>Long</code>, <code>UByte</code>, <code>UShort</code>, <code>UInt</code>, and <code>ULong</code>.</p> 
  <h4><a id="user-content-trig" class="anchor" href="https://github.com/non/spire#trig" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Trig</h4> 
  <p>Trig provides an abstraction for any type which defines trigonometric functions. To do this, types should be able to reasonably approximate real values.</p> 
  <ul> 
   <li><em>Trig</em> 
    <ul> 
     <li>e: Euler's number, <code>2.71828...</code></li> 
     <li>pi: Ratio of circle's circumference to diameter, <code>3.14159...</code></li> 
     <li>exp: exponential function, <code>e^x</code></li> 
     <li>expm1: <code>e^x - 1</code></li> 
     <li>log: natural logarithm</li> 
     <li>log1p: <code>log(x + 1)</code></li> 
     <li>sin, cos, tan: sine, cosine, and tangent, the standard functions of angles</li> 
     <li>asin, acos, atan, atan2: inverse functions</li> 
     <li>sinh, cosh, tanh: hyperbolic functions</li> 
     <li>toRadians, toDegrees: convert between angle units</li> 
    </ul></li> 
  </ul> 
  <h3><a id="user-content-syntax" class="anchor" href="https://github.com/non/spire#syntax" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Syntax</h3> 
  <p>Using string interpolation and macros, Spire provides convenient syntax for number types. These macros are evaluated at compile-time, and any errors they encounter will occur at compile-time.</p> 
  <p>For example:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">spire.syntax.literals.</span><span class="pl-v">_</span>

<span class="pl-c"><span class="pl-c">//</span> bytes and shorts</span>
<span class="pl-k">val</span> <span class="pl-en">x</span> <span class="pl-k">=</span> b<span class="pl-s"><span class="pl-pds">"</span>100<span class="pl-pds">"</span></span> <span class="pl-c"><span class="pl-c">//</span> without type annotation!</span>
<span class="pl-k">val</span> <span class="pl-en">y</span> <span class="pl-k">=</span> h<span class="pl-s"><span class="pl-pds">"</span>999<span class="pl-pds">"</span></span>
<span class="pl-k">val</span> <span class="pl-en">mask</span> <span class="pl-k">=</span> b<span class="pl-s"><span class="pl-pds">"</span>255<span class="pl-pds">"</span></span> <span class="pl-c"><span class="pl-c">//</span> unsigned constant converted to signed (-1)</span>

<span class="pl-c"><span class="pl-c">//</span> rationals</span>
<span class="pl-k">val</span> <span class="pl-en">n1</span> <span class="pl-k">=</span> r<span class="pl-s"><span class="pl-pds">"</span>1/3<span class="pl-pds">"</span></span>
<span class="pl-k">val</span> <span class="pl-en">n2</span> <span class="pl-k">=</span> r<span class="pl-s"><span class="pl-pds">"</span>1599/115866<span class="pl-pds">"</span></span> <span class="pl-c"><span class="pl-c">//</span> simplified at compile-time to 13/942</span>

<span class="pl-c"><span class="pl-c">//</span> support different radix literals</span>
<span class="pl-k">import</span> <span class="pl-v">spire.syntax.literals.radix.</span><span class="pl-v">_</span>

<span class="pl-c"><span class="pl-c">//</span> representations of the number 23</span>
<span class="pl-k">val</span> <span class="pl-en">a</span> <span class="pl-k">=</span> x2<span class="pl-s"><span class="pl-pds">"</span>10111<span class="pl-pds">"</span></span> <span class="pl-c"><span class="pl-c">//</span> binary</span>
<span class="pl-k">val</span> <span class="pl-en">b</span> <span class="pl-k">=</span> x8<span class="pl-s"><span class="pl-pds">"</span>27<span class="pl-pds">"</span></span> <span class="pl-c"><span class="pl-c">//</span> octal</span>
<span class="pl-k">val</span> <span class="pl-en">c</span> <span class="pl-k">=</span> x16<span class="pl-s"><span class="pl-pds">"</span>17<span class="pl-pds">"</span></span> <span class="pl-c"><span class="pl-c">//</span> hex</span>

<span class="pl-c"><span class="pl-c">//</span> SI notation for large numbers</span>
<span class="pl-k">import</span> <span class="pl-v">spire.syntax.literals.si.</span><span class="pl-v">_ </span><span class="pl-c"><span class="pl-c">//</span> .us and .eu also available</span>

<span class="pl-k">val</span> <span class="pl-en">w</span> <span class="pl-k">=</span> i<span class="pl-s"><span class="pl-pds">"</span>1 944 234 123<span class="pl-pds">"</span></span> <span class="pl-c"><span class="pl-c">//</span> Int</span>
<span class="pl-k">val</span> <span class="pl-en">x</span> <span class="pl-k">=</span> j<span class="pl-s"><span class="pl-pds">"</span>89 234 614 123 234 772<span class="pl-pds">"</span></span> <span class="pl-c"><span class="pl-c">//</span> Long</span>
<span class="pl-k">val</span> <span class="pl-en">y</span> <span class="pl-k">=</span> big<span class="pl-s"><span class="pl-pds">"</span>123 234 435 456 567 678 234 123 112 234 345<span class="pl-pds">"</span></span> <span class="pl-c"><span class="pl-c">//</span> BigInt</span>
<span class="pl-k">val</span> <span class="pl-en">z</span> <span class="pl-k">=</span> dec<span class="pl-s"><span class="pl-pds">"</span>1 234 456 789.123456789098765<span class="pl-pds">"</span></span> <span class="pl-c"><span class="pl-c">//</span> BigDecimal</span></pre>
  </div> 
  <p>Spire also provides a loop macro called <code>cfor</code> whose syntax bears a slight resemblance to a traditional for-loop from C or Java. This macro expands to a tail-recursive function, which will inline literal function arguments.</p> 
  <p>The macro can be nested in itself and compares favorably with other looping constructs in Scala such as <code>for</code> and <code>while</code>:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">spire.syntax.cfor.</span><span class="pl-v">_</span>

<span class="pl-c"><span class="pl-c">//</span> print numbers 1 through 10</span>
cfor(<span class="pl-c1">0</span>)(_ <span class="pl-k">&lt;</span> <span class="pl-c1">10</span>, _ <span class="pl-k">+</span> <span class="pl-c1">1</span>) { i <span class="pl-k">=&gt;</span>
  println(i)
}

<span class="pl-c"><span class="pl-c">//</span> naive sorting algorithm</span>
<span class="pl-k">def</span> <span class="pl-en">selectionSort</span>(<span class="pl-v">ns</span>: <span class="pl-en">Array</span>[<span class="pl-k">Int</span>]) {
  <span class="pl-k">val</span> <span class="pl-en">limit</span> <span class="pl-k">=</span> ns.length <span class="pl-k">-</span><span class="pl-c1">1</span>
  cfor(<span class="pl-c1">0</span>)(_ <span class="pl-k">&lt;</span> limit, _ <span class="pl-k">+</span> <span class="pl-c1">1</span>) { i <span class="pl-k">=&gt;</span>
    <span class="pl-k">var</span> <span class="pl-en">k</span> <span class="pl-k">=</span> i
    <span class="pl-k">val</span> <span class="pl-en">n</span> <span class="pl-k">=</span> ns(i)
    cfor(i <span class="pl-k">+</span> <span class="pl-c1">1</span>)(_ <span class="pl-k">&lt;=</span> limit, _ <span class="pl-k">+</span> <span class="pl-c1">1</span>) { j <span class="pl-k">=&gt;</span>
      <span class="pl-k">if</span> (ns(j) <span class="pl-k">&lt;</span> ns(k)) k <span class="pl-k">=</span> j
    }
    ns(i) <span class="pl-k">=</span> ns(k)
    ns(k) <span class="pl-k">=</span> n
  }
}</pre>
  </div> 
  <h3><a id="user-content-sorting-selection-and-searching" class="anchor" href="https://github.com/non/spire#sorting-selection-and-searching" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Sorting, Selection, and Searching</h3> 
  <p>Since Spire provides a specialized ordering type class, it makes sense that it also provides its own methods for doing operations based on order. These methods are defined on arrays and occur in-place, mutating the array. Other collections can take advantage of sorting by converting to an array, sorting, and converting back (which is what the Scala collections framework already does in most cases). Thus, Spire supports both mutable arrays and immutable collections.</p> 
  <p>Sorting methods can be found in the <code>spire.math.Sorting</code> object. They are:</p> 
  <ul> 
   <li><code>quickSort</code> fastest, nlog(n), not stable with potential n^2 worst-case</li> 
   <li><code>mergeSort</code> also fast, nlog(n), stable but allocates extra temporary space</li> 
   <li><code>insertionSort</code> n^2 but stable and fast for small arrays</li> 
   <li><code>sort</code> alias for <code>quickSort</code></li> 
  </ul> 
  <p>Both <code>mergeSort</code> and <code>quickSort</code> delegate to <code>insertionSort</code> when dealing with arrays (or slices) below a certain length. So, it would be more accurate to describe them as hybrid sorts.</p> 
  <p>Selection methods can be found in an analagous <code>spire.math.Selection</code> object. Given an array and an index <code>k</code> these methods put the <em>kth</em> largest element at position <code>k</code>, ensuring that all preceeding elements are less-than or equal-to, and all succeeding elements are greater-than or equal-to, the <em>kth</em> element.</p> 
  <p>There are two methods defined:</p> 
  <ul> 
   <li><code>quickSelect</code> usually faster, not stable, potentially bad worst-case</li> 
   <li><code>linearSelect</code> usually slower, but with guaranteed linear complexity</li> 
   <li><code>select</code> alias for <code>quickSelect</code></li> 
  </ul> 
  <p>Searching methods are located in the <code>spire.math.Searching</code> object. Given a sorted array (or indexed sequence), these methods will locate the index of the desired element (or return -1 if it is not found).</p> 
  <ul> 
   <li><code>search(array, item)</code> finds the index of <code>item</code> in <code>array</code></li> 
   <li><code>search(array, item, lower, upper)</code> only searches between <code>lower</code> and <code>upper</code>.</li> 
  </ul> 
  <p>Searching also supports a more esoteric method: <code>minimalElements</code>. This method returns the minimal elements of a partially-ordered set.</p> 
  <h3><a id="user-content-pseudo-random-number-generators" class="anchor" href="https://github.com/non/spire#pseudo-random-number-generators" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Pseudo-Random Number Generators</h3> 
  <p>Spire comes with many different PRNG implementations, which extends the <code>spire.random.Generator</code> interface. Generators are mutable RNGs that support basic operations like <code>nextInt</code>. Unlike Java, generators are not threadsafe by default; synchronous instances can be attained by calling the <code>.sync</code> method.</p> 
  <p>Spire supports generating random instances of arbitrary types using the <code>spire.random.Dist[A]</code> type class. These instances represent a strategy for getting random values using a <code>Generator</code> instance. For instance:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">spire.implicits.</span><span class="pl-v">_</span>
<span class="pl-k">import</span> <span class="pl-v">spire.math.</span><span class="pl-v">_</span>
<span class="pl-k">import</span> <span class="pl-v">spire.random.</span><span class="pl-v">_</span>

<span class="pl-k">val</span> <span class="pl-en">rng</span> <span class="pl-k">=</span> <span class="pl-en">Cmwc5</span>()

<span class="pl-c"><span class="pl-c">//</span> produces a double in [0.0, 1.0)</span>
<span class="pl-k">val</span> <span class="pl-en">n</span> <span class="pl-k">=</span> rng.next[<span class="pl-k">Double</span>]

<span class="pl-c"><span class="pl-c">//</span> produces a complex number, with real and imaginary parts in [0.0, 1.0)</span>
<span class="pl-k">val</span> <span class="pl-en">c</span> <span class="pl-k">=</span> rng.next[<span class="pl-en">Complex</span>[<span class="pl-k">Double</span>]]

<span class="pl-c"><span class="pl-c">//</span> produces a map with ~10-20 entries</span>
<span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">nextmap</span> <span class="pl-k">=</span> <span class="pl-en">Dist</span>.map[<span class="pl-k">Int</span>, <span class="pl-en">Complex</span>[<span class="pl-k">Double</span>]](<span class="pl-c1">10</span>, <span class="pl-c1">20</span>)
<span class="pl-k">val</span> <span class="pl-en">m</span> <span class="pl-k">=</span> rng.next[<span class="pl-en">Map</span>[<span class="pl-k">Int</span>, <span class="pl-en">Complex</span>[<span class="pl-k">Double</span>]]]</pre>
  </div> 
  <p>Unlike generators, <code>Dist[A]</code> instances are immutable and composable, supporting operations like <code>map</code>, <code>flatMap</code>, and <code>filter</code>. Many default instances are provided, and it's easy to create custom instances for user-defined types.</p> 
  <h3><a id="user-content-miscellany" class="anchor" href="https://github.com/non/spire#miscellany" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Miscellany</h3> 
  <p>In addition, Spire provides many other methods which are "missing" from <code>java.Math</code> (and <code>scala.math</code>), such as:</p> 
  <ul> 
   <li><code>log(BigDecimal): BigDecimal</code></li> 
   <li><code>exp(BigDecimal): BigDecimal</code></li> 
   <li><code>pow(BigDecimal): BigDecimal</code></li> 
   <li><code>pow(Long): Long</code></li> 
   <li><code>gcd(Long, Long): Long</code></li> 
   <li><em>and so on...</em></li> 
  </ul> 
  <h3><a id="user-content-benchmarks" class="anchor" href="https://github.com/non/spire#benchmarks" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Benchmarks</h3> 
  <p>In addition to unit tests, Spire comes with a relatively fleshed-out set of micro-benchmarks written against Caliper. To run the benchmarks from within SBT, change to the <code>benchmark</code> subproject and then <code>run</code> to see a list of benchmarks:</p> 
  <pre><code>$ sbt
[info] Set current project to spire (in build file:/Users/erik/w/spire/)
&gt; project benchmark
[info] Set current project to benchmark (in build file:/Users/erik/w/spire/)
&gt; run

Multiple main classes detected, select one to run:

 [1] spire.benchmark.AnyValAddBenchmarks
 [2] spire.benchmark.AnyValSubtractBenchmarks
 [3] spire.benchmark.AddBenchmarks
 [4] spire.benchmark.GcdBenchmarks
 [5] spire.benchmark.RationalBenchmarks
 [6] spire.benchmark.JuliaBenchmarks
 [7] spire.benchmark.ComplexAddBenchmarks
 [8] spire.benchmark.CForBenchmarks
 [9] spire.benchmark.SelectionBenchmarks
 [10] spire.benchmark.Mo5Benchmarks
 [11] spire.benchmark.SortingBenchmarks
 [12] spire.benchmark.ScalaVsSpireBenchmarks
 [13] spire.benchmark.MaybeAddBenchmarks
</code></pre> 
  <p>You can also run a particular benchmark with <code>run-main</code>, for instance:</p> 
  <pre><code>&gt; run-main spire.benchmark.JuliaBenchmarks
</code></pre> 
  <p>If you plan to contribute to Spire, please make sure to run the relevant benchmarks to be sure that your changes don't impact performance. Benchmarks usually include comparisons against equivalent Scala or Java classes to try to measure relative as well as absolute performance.</p> 
  <h3><a id="user-content-caveats" class="anchor" href="https://github.com/non/spire#caveats" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Caveats</h3> 
  <p>Code is offered as-is, with no implied warranty of any kind. Comments, criticisms, and/or praise are welcome, especially from numerical analysts! ;)</p> 
  <p>Copyright 2011-2015 Erik Osheim, Tom Switzer</p> 
  <p>A full list of contributors can be found in <a href="https://github.com/non/spire/blob/master/AUTHORS.md" target="_blank">AUTHORS.md</a>.</p> 
  <p>The MIT software license is attached in the <a href="https://github.com/non/spire/blob/master/COPYING" target="_blank">COPYING</a> file.</p> 
 </article>
</div>