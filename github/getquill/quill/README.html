<div class="announce instapaper_body md" data-path="README.md" id="readme">
 <article class="markdown-body entry-content" itemprop="text">
  <h2><a id="user-content-important-this-is-the-documentation-for-the-latest-snapshot-version-please-refer-to-the-website-at-httpgetquillio-for-the-lastest-releases-documentation" class="anchor" href="https://github.com/getquill/quill#important-this-is-the-documentation-for-the-latest-snapshot-version-please-refer-to-the-website-at-httpgetquillio-for-the-lastest-releases-documentation" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>IMPORTANT: This is the documentation for the latest <code>SNAPSHOT</code> version. Please refer to the website at <a href="http://getquill.io" target="_blank">http://getquill.io</a> for the lastest release's documentation.</h2> 
  <p><a href="https://raw.githubusercontent.com/getquill/quill/master/quill.png" target="_blank"><img src="https://raw.githubusercontent.com/getquill/quill/master/quill.png" alt="quill" style="max-width:100%;"></a></p> 
  <p>Compile-time Language Integrated Query for Scala</p> 
  <p><a href="https://travis-ci.org/getquill/quill" target="_blank"><img src="https://camo.githubusercontent.com/06fc7712ef3619bbb5c065212dc55387e3ab4b42/68747470733a2f2f7472617669732d63692e6f72672f6765747175696c6c2f7175696c6c2e7376673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.org/getquill/quill.svg?branch=master" style="max-width:100%;"></a> <a href="https://www.codacy.com/app/fwbrasil/quill" target="_blank"><img src="https://camo.githubusercontent.com/fcaa339d2d41f298cad10ffdd581c283bf6c3e3f/68747470733a2f2f6170692e636f646163792e636f6d2f70726f6a6563742f62616467652f67726164652f3336616238346337666634333438303438396466396237333132613462646331" alt="Codacy Badge" data-canonical-src="https://api.codacy.com/project/badge/grade/36ab84c7ff43480489df9b7312a4bdc1" style="max-width:100%;"></a> <a href="https://codecov.io/github/getquill/quill?branch=master" target="_blank"><img src="https://camo.githubusercontent.com/e662e54aaaf38d8cb0de3d231c274bb9e0e25d57/68747470733a2f2f636f6465636f762e696f2f6769746875622f6765747175696c6c2f7175696c6c2f636f7665726167652e7376673f6272616e63683d6d6173746572" alt="codecov.io" data-canonical-src="https://codecov.io/github/getquill/quill/coverage.svg?branch=master" style="max-width:100%;"></a> <a href="https://gitter.im/getquill/quill?utm_source=badge&amp;utm_medium=badge&amp;utm_campaign=pr-badge&amp;utm_content=badge" target="_blank"><img src="https://camo.githubusercontent.com/9b52186233ef85483f5c65b95243444e9392be66/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f6769747465722d6a6f696e253230636861742d677265656e2e737667" alt="Join the chat at https://gitter.im/getquill/quill" data-canonical-src="https://img.shields.io/badge/gitter-join%20chat-green.svg" style="max-width:100%;"></a> <a href="https://www.versioneye.com/user/projects/56ea4da64e714c0035e76353" target="_blank"><img src="https://camo.githubusercontent.com/70aae34413fc798644e9fcb955f10f1c80b780cc/68747470733a2f2f7777772e76657273696f6e6579652e636f6d2f757365722f70726f6a656374732f3536656134646136346537313463303033356537363335332f62616467652e7376673f7374796c653d666c6174" alt="Dependency Status" data-canonical-src="https://www.versioneye.com/user/projects/56ea4da64e714c0035e76353/badge.svg?style=flat" style="max-width:100%;"></a> <a href="https://maven-badges.herokuapp.com/maven-central/io.getquill/quill_2.11" target="_blank"><img src="https://camo.githubusercontent.com/60effa3a96aa8d444dba4203bf63dd718d20deb1/68747470733a2f2f6d6176656e2d6261646765732e6865726f6b756170702e636f6d2f6d6176656e2d63656e7472616c2f696f2e6765747175696c6c2f7175696c6c5f322e31312f62616467652e737667" alt="Maven Central" data-canonical-src="https://maven-badges.herokuapp.com/maven-central/io.getquill/quill_2.11/badge.svg" style="max-width:100%;"></a></p> 
  <p>Quill provides a Quoted Domain Specific Language (<a href="http://homepages.inf.ed.ac.uk/wadler/papers/qdsl/qdsl.pdf" target="_blank">QDSL</a>) to express queries in Scala and execute them in a target language. The library's core is designed to support multiple target languages, currently featuring specializations for Structured Query Language (<a href="https://en.wikipedia.org/wiki/SQL" target="_blank">SQL</a>) and Cassandra Query Language (<a href="https://cassandra.apache.org/doc/cql3/CQL.html#selectStmt" target="_blank">CQL</a>).</p> 
  <p><a href="https://raw.githubusercontent.com/getquill/quill/master/example.gif" target="_blank"><img src="https://raw.githubusercontent.com/getquill/quill/master/example.gif" alt="example" style="max-width:100%;"></a></p> 
  <ol> 
   <li><strong>Boilerplate-free mapping</strong>: The database schema is mapped using simple case classes.</li> 
   <li><strong>Quoted DSL</strong>: Queries are defined inside a <code>quote</code> block. Quill parses each quoted block of code (quotation) at compile time and translates them to an internal Abstract Syntax Tree (AST)</li> 
   <li><strong>Compile-time query generation</strong>: The <code>ctx.run</code> call reads the quotation's AST and translates it to the target language at compile time, emitting the query string as a compilation message. As the query string is known at compile time, the runtime overhead is very low and similar to using the database driver directly.</li> 
   <li><strong>Compile-time query validation</strong>: If configured, the query is verified against the database at compile time and the compilation fails if it is not valid. The query validation <strong>does not</strong> alter the database state.</li> 
  </ol> 
  <h1><a id="user-content-quotation" class="anchor" href="https://github.com/getquill/quill#quotation" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Quotation</h1> 
  <h2><a id="user-content-introduction" class="anchor" href="https://github.com/getquill/quill#introduction" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Introduction</h2> 
  <p>The QDSL allows the user to write plain Scala code, leveraging scala's syntax and type system. Quotations are created using the <code>quote</code> method and can contain any excerpt of code that uses supported operations. To create quotations, first create a context instance. Please see the <a href="https://github.com/getquill/quill#contexts" target="_blank">context</a> section for more details on the different context available.</p> 
  <p>For this documentation, a special type of context that acts as a <a href="https://github.com/getquill/quill#mirror-context" target="_blank">mirror</a> is used:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">io.getquill.</span><span class="pl-v">_</span>

<span class="pl-k">val</span> <span class="pl-en">ctx</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">SqlMirrorContext</span>[<span class="pl-en">MirrorSqlDialect</span>, <span class="pl-en">Literal</span>]</pre>
  </div> 
  <blockquote> 
   <h3><a id="user-content-note-scalafiddle-is-a-great-tool-to-try-out-quill-without-having-to-prepare-a-local-environment-it-works-with-mirror-contexts-see-this-fiddle-as-an-example" class="anchor" href="https://github.com/getquill/quill#note-scalafiddle-is-a-great-tool-to-try-out-quill-without-having-to-prepare-a-local-environment-it-works-with-mirror-contexts-see-this-fiddle-as-an-example" aria-hidden="true" target="_blank">
     <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
      <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
     </svg></a><strong>Note:</strong> <a href="http://scalafiddle.io" target="_blank">Scalafiddle</a> is a great tool to try out Quill without having to prepare a local environment. It works with <a href="https://github.com/getquill/quill#mirror-context" target="_blank">mirror contexts</a>, see <a href="https://scalafiddle.io/sf/pMg4JvY/1" target="_blank">this</a> fiddle as an example.</h3> 
  </blockquote> 
  <p>The context instance provides all types and methods to deal quotations:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">ctx.</span><span class="pl-v">_</span></pre>
  </div> 
  <p>A quotation can be a simple value:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">pi</span> <span class="pl-k">=</span> quote(<span class="pl-c1">3.14159</span>)</pre>
  </div> 
  <p>And be used within another quotation:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Circle</span>(<span class="pl-v">radius</span>: <span class="pl-k">Float</span>)

<span class="pl-k">val</span> <span class="pl-en">areas</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Circle</span>].map(c <span class="pl-k">=&gt;</span> pi <span class="pl-k">*</span> c.radius <span class="pl-k">*</span> c.radius)
}</pre>
  </div> 
  <p>Quotations can also contain high-order functions and inline values:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">area</span> <span class="pl-k">=</span> quote {
  (<span class="pl-v">c</span>: <span class="pl-en">Circle</span>) <span class="pl-k">=&gt;</span> {
    <span class="pl-k">val</span> <span class="pl-en">r2</span> <span class="pl-k">=</span> c.radius <span class="pl-k">*</span> c.radius
    pi <span class="pl-k">*</span> r2
  }
}</pre>
  </div> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">areas</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Circle</span>].map(c <span class="pl-k">=&gt;</span> area(c))
}</pre>
  </div> 
  <p>Quill's normalization engine applies reduction steps before translating the quotation to the target language. The correspondent normalized quotation for both versions of the <code>areas</code> query is:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">areas</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Circle</span>].map(c <span class="pl-k">=&gt;</span> <span class="pl-c1">3.14159</span> <span class="pl-k">*</span> c.radius <span class="pl-k">*</span> c.radius)
}</pre>
  </div> 
  <p>Scala doesn't have support for high-order functions with type parameters. Quill supports anonymous classes with an apply method for this purpose:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">existsAny</span> <span class="pl-k">=</span> quote {
  new {
    <span class="pl-k">def</span> <span class="pl-en">apply</span>[<span class="pl-en">T</span>](<span class="pl-v">xs</span>: <span class="pl-en">Query</span>[<span class="pl-en">T</span>])(<span class="pl-v">p</span>: <span class="pl-en">T</span> <span class="pl-k">=&gt;</span> <span class="pl-k">Boolean</span>) <span class="pl-k">=</span>
        xs.filter(p(_)).nonEmpty
  }
}

<span class="pl-k">val</span> <span class="pl-en">q</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Circle</span>].filter { c1 <span class="pl-k">=&gt;</span>
    existsAny(query[<span class="pl-en">Circle</span>])(c2 <span class="pl-k">=&gt;</span> c2.radius <span class="pl-k">&gt;</span> c1.radius)
  }
}</pre>
  </div> 
  <h2><a id="user-content-compile-time-quotations" class="anchor" href="https://github.com/getquill/quill#compile-time-quotations" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Compile-time quotations</h2> 
  <p>Quotations are both compile-time and runtime values. Quill uses a type refinement to store the quotation's AST as an annotation available at compile-time and the <code>q.ast</code> method exposes the AST as runtime value.</p> 
  <p>It is important to avoid giving explicit types to quotations when possible. For instance, this quotation can't be read at compile-time as the type refinement is lost:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-c">// Avoid type widening (Quoted[Query[Circle]]), or else the quotation will be dynamic.</span>
<span class="pl-k">val</span> <span class="pl-en">q</span><span class="pl-k">:</span> <span class="pl-en">Quoted</span>[<span class="pl-en">Query</span>[<span class="pl-en">Circle</span>]] <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Circle</span>].filter(c <span class="pl-k">=&gt;</span> c.radius <span class="pl-k">&gt;</span> <span class="pl-c1">10</span>)
}

ctx.run(q) <span class="pl-c">// Dynamic query</span></pre>
  </div> 
  <p>Quill falls back to runtime normalization and query generation if the quotation's AST can't be read at compile-time. Please refer to <a href="https://github.com/getquill/quill#dynamic-queries" target="_blank">dynamic queries</a> for more information.</p> 
  <h4><a id="user-content-inline-queries" class="anchor" href="https://github.com/getquill/quill#inline-queries" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Inline queries</h4> 
  <p>Quoting is implicit when writing a query in a <code>run</code> statement.</p> 
  <div class="highlight highlight-source-scala">
   <pre>ctx.run(query[<span class="pl-en">Circle</span>].map(_.radius))
<span class="pl-c">// SELECT r.radius FROM Circle r</span></pre>
  </div> 
  <h2><a id="user-content-bindings" class="anchor" href="https://github.com/getquill/quill#bindings" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Bindings</h2> 
  <p>Quotations are designed to be self-contained, without references to runtime values outside their scope. There are two mechanisms to explicitly bind runtime values to a quotation execution.</p> 
  <h4><a id="user-content-lifted-values" class="anchor" href="https://github.com/getquill/quill#lifted-values" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Lifted values</h4> 
  <p>A runtime value can be lifted to a quotation through the method <code>lift</code>:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">def</span> <span class="pl-en">biggerThan</span>(<span class="pl-v">i</span>: <span class="pl-k">Float</span>) <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Circle</span>].filter(r <span class="pl-k">=&gt;</span> r.radius <span class="pl-k">&gt;</span> lift(i))
}
ctx.run(biggerThan(<span class="pl-c1">10</span>)) <span class="pl-c">// SELECT r.radius FROM Circle r WHERE r.radius &gt; ?</span></pre>
  </div> 
  <h4><a id="user-content-lifted-queries" class="anchor" href="https://github.com/getquill/quill#lifted-queries" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Lifted queries</h4> 
  <p>A <code>Traversable</code> instance can be lifted as a <code>Query</code>. There are two main usages for lifted queries:</p> 
  <p><strong>contains</strong></p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">def</span> <span class="pl-en">find</span>(<span class="pl-v">radiusList</span>: <span class="pl-en">List</span>[<span class="pl-k">Float</span>]) <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Circle</span>].filter(r <span class="pl-k">=&gt;</span> liftQuery(radiusList).contains(r.radius))
}
ctx.run(find(<span class="pl-en">List</span>(<span class="pl-c1">1.1F</span>, <span class="pl-c1">1.2F</span>))) 
<span class="pl-c">// SELECT r.radius FROM Circle r WHERE r.radius IN (?)</span></pre>
  </div> 
  <p><strong>batch action</strong></p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">def</span> <span class="pl-en">insert</span>(<span class="pl-v">circles</span>: <span class="pl-en">List</span>[<span class="pl-en">Circle</span>]) <span class="pl-k">=</span> quote {
  liftQuery(circles).foreach(c <span class="pl-k">=&gt;</span> query[<span class="pl-en">Circle</span>].insert(c))
}
ctx.run(insert(<span class="pl-en">List</span>(<span class="pl-en">Circle</span>(<span class="pl-c1">1.1F</span>), <span class="pl-en">Circle</span>(<span class="pl-c1">1.2F</span>)))) 
<span class="pl-c">// INSERT INTO Circle (radius) VALUES (?)</span></pre>
  </div> 
  <h2><a id="user-content-schema" class="anchor" href="https://github.com/getquill/quill#schema" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Schema</h2> 
  <p>The database schema is represented by case classes. By default, quill uses the class and field names as the database identifiers:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Circle</span>(<span class="pl-v">radius</span>: <span class="pl-k">Float</span>)

<span class="pl-k">val</span> <span class="pl-en">q</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Circle</span>].filter(c <span class="pl-k">=&gt;</span> c.radius <span class="pl-k">&gt;</span> <span class="pl-c1">1</span>)
}

ctx.run(q) <span class="pl-c">// SELECT c.radius FROM Circle c WHERE c.radius &gt; 1</span></pre>
  </div> 
  <p>Alternatively, the identifiers can be customized:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">circles</span> <span class="pl-k">=</span> quote {
  querySchema[<span class="pl-en">Circle</span>](<span class="pl-s"><span class="pl-pds">"</span>circle_table<span class="pl-pds">"</span></span>, _.radius <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>radius_column<span class="pl-pds">"</span></span>)
}

<span class="pl-k">val</span> <span class="pl-en">q</span> <span class="pl-k">=</span> quote {
  circles.filter(c <span class="pl-k">=&gt;</span> c.radius <span class="pl-k">&gt;</span> <span class="pl-c1">1</span>)
}

ctx.run(q)
<span class="pl-c">// SELECT c.radius_column FROM circle_table c WHERE c.radius_column &gt; 1</span></pre>
  </div> 
  <p>If multiple tables require custom identifiers, it is good practice to define a <code>schema</code> object with all table queries to be reused across multiple queries:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Circle</span>(<span class="pl-v">radius</span>: <span class="pl-k">Int</span>)
<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Rectangle</span>(<span class="pl-v">length</span>: <span class="pl-k">Int</span>, <span class="pl-v">width</span>: <span class="pl-k">Int</span>)
<span class="pl-k">object</span> <span class="pl-en">schema</span> {
  <span class="pl-k">val</span> <span class="pl-en">circles</span> <span class="pl-k">=</span> quote {
    querySchema[<span class="pl-en">Circle</span>](
        <span class="pl-s"><span class="pl-pds">"</span>circle_table<span class="pl-pds">"</span></span>,
        _.radius <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>radius_column<span class="pl-pds">"</span></span>)
  }
  <span class="pl-k">val</span> <span class="pl-en">rectangles</span> <span class="pl-k">=</span> quote {
    querySchema[<span class="pl-en">Rectangle</span>](
        <span class="pl-s"><span class="pl-pds">"</span>rectangle_table<span class="pl-pds">"</span></span>,
        _.length <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>length_column<span class="pl-pds">"</span></span>,
        _.width <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>width_column<span class="pl-pds">"</span></span>)
  }
}</pre>
  </div> 
  <h4><a id="user-content-database-generated-values" class="anchor" href="https://github.com/getquill/quill#database-generated-values" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Database-generated values</h4> 
  <p>It is possible to make a column that is a generated by the database to be ignored during insertions and returned as a returning value.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Product</span>(<span class="pl-v">id</span>: <span class="pl-k">Long</span>, <span class="pl-v">description</span>: <span class="pl-k">String</span>, <span class="pl-v">sku</span>: <span class="pl-k">Long</span>)

<span class="pl-k">val</span> <span class="pl-en">q</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Product</span>].insert(lift(<span class="pl-en">Product</span>(<span class="pl-c1">0L</span>, <span class="pl-s"><span class="pl-pds">"</span>My Product<span class="pl-pds">"</span></span>, <span class="pl-c1">1011L</span>))).returning(_.id)
}

<span class="pl-k">val</span> <span class="pl-en">returnedIds</span> <span class="pl-k">=</span> ctx.run(q)
<span class="pl-c">// INSERT INTO Product (description,sku) VALUES (?, ?)</span></pre>
  </div> 
  <h4><a id="user-content-embedded-case-classes" class="anchor" href="https://github.com/getquill/quill#embedded-case-classes" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Embedded case classes</h4> 
  <p>Quill supports nested <code>Embedded</code> case classes:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Contact</span>(<span class="pl-v">phone</span>: <span class="pl-k">String</span>, <span class="pl-v">address</span>: <span class="pl-k">String</span>) <span class="pl-k">extends</span> <span class="pl-e">Embedded</span>
<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Person</span>(<span class="pl-v">id</span>: <span class="pl-k">Int</span>, <span class="pl-v">name</span>: <span class="pl-k">String</span>, <span class="pl-v">contact</span>: <span class="pl-en">Contact</span>)

ctx.run(query[<span class="pl-en">Person</span>])
<span class="pl-c">// SELECT x.id, x.name, x.phone, x.address FROM Person x</span></pre>
  </div> 
  <p>Note that default naming behavior uses the name of the nested case class properties. It's possible to override this default behavior using a custom <code>schema</code>:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Contact</span>(<span class="pl-v">phone</span>: <span class="pl-k">String</span>, <span class="pl-v">address</span>: <span class="pl-k">String</span>) <span class="pl-k">extends</span> <span class="pl-e">Embedded</span>
<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Person</span>(<span class="pl-v">id</span>: <span class="pl-k">Int</span>, <span class="pl-v">name</span>: <span class="pl-k">String</span>, <span class="pl-v">homeContact</span>: <span class="pl-en">Contact</span>, <span class="pl-v">workContact</span>: <span class="pl-en">Contact</span>)

<span class="pl-k">val</span> <span class="pl-en">q</span> <span class="pl-k">=</span> quote {
  querySchema[<span class="pl-en">Person</span>](
    <span class="pl-s"><span class="pl-pds">"</span>Person<span class="pl-pds">"</span></span>,
    _.homeContact.phone   <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>homePhone<span class="pl-pds">"</span></span>,
    _.homeContact.address <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>homeAdress<span class="pl-pds">"</span></span>,
    _.workContact.phone   <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>workPhone<span class="pl-pds">"</span></span>,
    _.workContact.address <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>workAdress<span class="pl-pds">"</span></span>
  )
}

ctx.run(q)
<span class="pl-c">// SELECT x.id, x.name, x.homePhone, x.homeAdress, x.workPhone, x.workAdress FROM Person x</span></pre>
  </div> 
  <h2><a id="user-content-queries" class="anchor" href="https://github.com/getquill/quill#queries" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Queries</h2> 
  <p>The overall abstraction of quill queries is use database tables as if they were in-memory collections. Scala for-comprehensions provide syntatic sugar to deal with this kind of monadic operations:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Person</span>(<span class="pl-v">id</span>: <span class="pl-k">Int</span>, <span class="pl-v">name</span>: <span class="pl-k">String</span>, <span class="pl-v">age</span>: <span class="pl-k">Int</span>)
<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Contact</span>(<span class="pl-v">personId</span>: <span class="pl-k">Int</span>, <span class="pl-v">phone</span>: <span class="pl-k">String</span>)

<span class="pl-k">val</span> <span class="pl-en">q</span> <span class="pl-k">=</span> quote {
  <span class="pl-k">for</span> {
    p <span class="pl-k">&lt;</span><span class="pl-k">-</span> query[<span class="pl-en">Person</span>] <span class="pl-k">if</span>(p.id <span class="pl-k">==</span> <span class="pl-c1">999</span>)
    c <span class="pl-k">&lt;</span><span class="pl-k">-</span> query[<span class="pl-en">Contact</span>] <span class="pl-k">if</span>(c.personId <span class="pl-k">==</span> p.id)
  } <span class="pl-k">yield</span> {
    (p.name, c.phone)
  }
}

ctx.run(q)
<span class="pl-c">// SELECT p.name, c.phone FROM Person p, Contact c WHERE (p.id = 999) AND (c.personId = p.id)</span></pre>
  </div> 
  <p>Quill normalizes the quotation and translates the monadic joins to applicative joins, generating a database-friendly query that avoids nested queries.</p> 
  <p>Any of the following features can be used together with the others and/or within a for-comprehension:</p> 
  <p><strong>filter</strong></p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">q</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].filter(p <span class="pl-k">=&gt;</span> p.age <span class="pl-k">&gt;</span> <span class="pl-c1">18</span>)
}

ctx.run(q)
<span class="pl-c">// SELECT p.id, p.name, p.age FROM Person p WHERE p.age &gt; 18</span></pre>
  </div> 
  <p><strong>map</strong></p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">q</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].map(p <span class="pl-k">=&gt;</span> p.name)
}

ctx.run(q)
<span class="pl-c">// SELECT p.name FROM Person p</span></pre>
  </div> 
  <p><strong>flatMap</strong></p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">q</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].filter(p <span class="pl-k">=&gt;</span> p.age <span class="pl-k">&gt;</span> <span class="pl-c1">18</span>).flatMap(p <span class="pl-k">=&gt;</span> query[<span class="pl-en">Contact</span>].filter(c <span class="pl-k">=&gt;</span> c.personId <span class="pl-k">==</span> p.id))
}

ctx.run(q)
<span class="pl-c">// SELECT c.personId, c.phone FROM Person p, Contact c WHERE (p.age &gt; 18) AND (c.personId = p.id)</span></pre>
  </div> 
  <p><strong>sortBy</strong></p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">q1</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].sortBy(p <span class="pl-k">=&gt;</span> p.age)
}

ctx.run(q1)
<span class="pl-c">// SELECT p.id, p.name, p.age FROM Person p ORDER BY p.age ASC NULLS FIRST</span>

<span class="pl-k">val</span> <span class="pl-en">q2</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].sortBy(p <span class="pl-k">=&gt;</span> p.age)(<span class="pl-en">Ord</span>.descNullsLast)
}

ctx.run(q2)
<span class="pl-c">// SELECT p.id, p.name, p.age FROM Person p ORDER BY p.age DESC NULLS LAST</span>

<span class="pl-k">val</span> <span class="pl-en">q3</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].sortBy(p <span class="pl-k">=&gt;</span> (p.name, p.age))(<span class="pl-en">Ord</span>(<span class="pl-en">Ord</span>.asc, <span class="pl-en">Ord</span>.desc))
}

ctx.run(q3)
<span class="pl-c">// SELECT p.id, p.name, p.age FROM Person p ORDER BY p.name ASC, p.age DESC</span></pre>
  </div> 
  <p><strong>drop/take</strong></p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">q</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].drop(<span class="pl-c1">2</span>).take(<span class="pl-c1">1</span>)
}

ctx.run(q)
<span class="pl-c">// SELECT x.id, x.name, x.age FROM Person x LIMIT 1 OFFSET 2</span></pre>
  </div> 
  <p><strong>groupBy</strong></p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">q</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].groupBy(p <span class="pl-k">=&gt;</span> p.age).map {
    <span class="pl-k">case</span> (age, people) <span class="pl-k">=&gt;</span>
      (age, people.size)
  }
}

ctx.run(q)
<span class="pl-c">// SELECT p.age, COUNT(*) FROM Person p GROUP BY p.age</span></pre>
  </div> 
  <p><strong>union</strong></p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">q</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].filter(p <span class="pl-k">=&gt;</span> p.age <span class="pl-k">&gt;</span> <span class="pl-c1">18</span>).union(query[<span class="pl-en">Person</span>].filter(p <span class="pl-k">=&gt;</span> p.age <span class="pl-k">&gt;</span> <span class="pl-c1">60</span>))
}

ctx.run(q)
<span class="pl-c">// SELECT x.id, x.name, x.age FROM (SELECT id, name, age FROM Person p WHERE p.age &gt; 18</span>
<span class="pl-c">// UNION SELECT id, name, age FROM Person p1 WHERE p1.age &gt; 60) x</span></pre>
  </div> 
  <p><strong>unionAll/++</strong></p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">q</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].filter(p <span class="pl-k">=&gt;</span> p.age <span class="pl-k">&gt;</span> <span class="pl-c1">18</span>).unionAll(query[<span class="pl-en">Person</span>].filter(p <span class="pl-k">=&gt;</span> p.age <span class="pl-k">&gt;</span> <span class="pl-c1">60</span>))
}

ctx.run(q)
<span class="pl-c">// SELECT x.id, x.name, x.age FROM (SELECT id, name, age FROM Person p WHERE p.age &gt; 18</span>
<span class="pl-c">// UNION ALL SELECT id, name, age FROM Person p1 WHERE p1.age &gt; 60) x</span>

<span class="pl-k">val</span> <span class="pl-en">q2</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].filter(p <span class="pl-k">=&gt;</span> p.age <span class="pl-k">&gt;</span> <span class="pl-c1">18</span>) <span class="pl-k">++</span> query[<span class="pl-en">Person</span>].filter(p <span class="pl-k">=&gt;</span> p.age <span class="pl-k">&gt;</span> <span class="pl-c1">60</span>)
}

ctx.run(q2)
<span class="pl-c">// SELECT x.id, x.name, x.age FROM (SELECT id, name, age FROM Person p WHERE p.age &gt; 18</span>
<span class="pl-c">// UNION ALL SELECT id, name, age FROM Person p1 WHERE p1.age &gt; 60) x</span></pre>
  </div> 
  <p><strong>aggregation</strong></p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">r</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].map(p <span class="pl-k">=&gt;</span> p.age)
}

ctx.run(r.min) <span class="pl-c">// SELECT MIN(p.age) FROM Person p</span>
ctx.run(r.max) <span class="pl-c">// SELECT MAX(p.age) FROM Person p</span>
ctx.run(r.avg) <span class="pl-c">// SELECT AVG(p.age) FROM Person p</span>
ctx.run(r.sum) <span class="pl-c">// SELECT SUM(p.age) FROM Person p</span>
ctx.run(r.size) <span class="pl-c">// SELECT COUNT(p.age) FROM Person p</span></pre>
  </div> 
  <p><strong>isEmpty/nonEmpty</strong></p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">q</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].filter{ p1 <span class="pl-k">=&gt;</span>
    query[<span class="pl-en">Person</span>].filter(p2 <span class="pl-k">=&gt;</span> p2.id <span class="pl-k">!=</span> p1.id <span class="pl-k">&amp;&amp;</span> p2.age <span class="pl-k">==</span> p1.age).isEmpty
  }
}

ctx.run(q)
<span class="pl-c">// SELECT p1.id, p1.name, p1.age FROM Person p1 WHERE</span>
<span class="pl-c">// NOT EXISTS (SELECT * FROM Person p2 WHERE (p2.id &lt;&gt; p1.id) AND (p2.age = p1.age))</span>

<span class="pl-k">val</span> <span class="pl-en">q2</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].filter{ p1 <span class="pl-k">=&gt;</span>
    query[<span class="pl-en">Person</span>].filter(p2 <span class="pl-k">=&gt;</span> p2.id <span class="pl-k">!=</span> p1.id <span class="pl-k">&amp;&amp;</span> p2.age <span class="pl-k">==</span> p1.age).nonEmpty
  }
}

ctx.run(q2)
<span class="pl-c">// SELECT p1.id, p1.name, p1.age FROM Person p1 WHERE</span>
<span class="pl-c">// EXISTS (SELECT * FROM Person p2 WHERE (p2.id &lt;&gt; p1.id) AND (p2.age = p1.age))</span></pre>
  </div> 
  <p><strong>contains</strong></p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">q</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].filter(p <span class="pl-k">=&gt;</span> liftQuery(<span class="pl-en">Set</span>(<span class="pl-c1">1</span>, <span class="pl-c1">2</span>)).contains(p.id))
}

ctx.run(q)
<span class="pl-c">// SELECT p.id, p.name, p.age FROM Person p WHERE p.id IN (?, ?)</span>

<span class="pl-k">val</span> <span class="pl-en">q1</span> <span class="pl-k">=</span> quote { (<span class="pl-v">ids</span>: <span class="pl-en">Query</span>[<span class="pl-k">Int</span>]) <span class="pl-k">=&gt;</span>
  query[<span class="pl-en">Person</span>].filter(p <span class="pl-k">=&gt;</span> ids.contains(p.id))
}

ctx.run(q1(liftQuery(<span class="pl-en">List</span>(<span class="pl-c1">1</span>, <span class="pl-c1">2</span>))))
<span class="pl-c">// SELECT p.id, p.name, p.age FROM Person p WHERE p.id IN (?, ?)</span>

<span class="pl-k">val</span> <span class="pl-en">peopleWithContacts</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].filter(p <span class="pl-k">=&gt;</span> query[<span class="pl-en">Contact</span>].filter(c <span class="pl-k">=&gt;</span> c.personId <span class="pl-k">==</span> p.id).nonEmpty)
}
<span class="pl-k">val</span> <span class="pl-en">q2</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].filter(p <span class="pl-k">=&gt;</span> peopleWithContacts.contains(p.id))
}

ctx.run(q2)
<span class="pl-c">// SELECT p.id, p.name, p.age FROM Person p WHERE p.id IN (SELECT p1.* FROM Person p1 WHERE EXISTS (SELECT c.* FROM Contact c WHERE c.personId = p1.id))</span></pre>
  </div> 
  <p><strong>distinct</strong></p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">q</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].map(p <span class="pl-k">=&gt;</span> p.age).distinct
}

ctx.run(q)
<span class="pl-c">// SELECT DISTINCT p.age FROM Person p</span></pre>
  </div> 
  <p><strong>nested</strong></p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">q</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].filter(p <span class="pl-k">=&gt;</span> p.name <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>John<span class="pl-pds">"</span></span>).nested.map(p <span class="pl-k">=&gt;</span> p.age)
}

ctx.run(q)
<span class="pl-c">// SELECT p.age FROM (SELECT p.age FROM Person p WHERE p.name = 'John') p</span></pre>
  </div> 
  <p><strong>joins</strong></p> 
  <p>In addition to applicative joins Quill also supports explicit joins (both inner and left/right/full outer joins).</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">q</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].join(query[<span class="pl-en">Contact</span>]).on((p, c) <span class="pl-k">=&gt;</span> c.personId <span class="pl-k">==</span> p.id)
}

ctx.run(q)
<span class="pl-c">// SELECT p.id, p.name, p.age, c.personId, c.phone•</span>
<span class="pl-c">// FROM Person p INNER JOIN Contact c ON c.personId = p.id</span>

<span class="pl-k">val</span> <span class="pl-en">q</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].leftJoin(query[<span class="pl-en">Contact</span>]).on((p, c) <span class="pl-k">=&gt;</span> c.personId <span class="pl-k">==</span> p.id)
}

ctx.run(q)
<span class="pl-c">// SELECT p.id, p.name, p.age, c.personId, c.phone•</span>
<span class="pl-c">// FROM Person p LEFT JOIN Contact c ON c.personId = p.id</span>
</pre>
  </div> 
  <p>The example joins above cover the simple case. What do you do when a query requires joining more than 2 tables?</p> 
  <p>With Quill the following multi-join queries are equivalent, choose according to preference:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Employer</span>(<span class="pl-v">id</span>: <span class="pl-k">Int</span>, <span class="pl-v">personId</span>: <span class="pl-k">Int</span>, <span class="pl-v">name</span>: <span class="pl-k">String</span>)

<span class="pl-k">val</span> <span class="pl-en">qFlat</span> <span class="pl-k">=</span> quote {
  <span class="pl-k">for</span>{
    (p,e) <span class="pl-k">&lt;</span><span class="pl-k">-</span> query[<span class="pl-en">Person</span>].join(query[<span class="pl-en">Employer</span>]).on(_.id <span class="pl-k">==</span> _.personId)
       c  <span class="pl-k">&lt;</span><span class="pl-k">-</span> query[<span class="pl-en">Contact</span>].leftJoin(_.personId <span class="pl-k">==</span> p.id)
  } <span class="pl-k">yield</span>(p, e, c)
}

<span class="pl-k">val</span> <span class="pl-en">qNested</span> <span class="pl-k">=</span> quote {
  <span class="pl-k">for</span>{
    ((p,e),c) <span class="pl-k">&lt;</span><span class="pl-k">-</span>
      query[<span class="pl-en">Person</span>].join(query[<span class="pl-en">Employer</span>]).on(_.id <span class="pl-k">==</span> _.personId)
      .leftJoin(query[<span class="pl-en">Contact</span>]).on(
        _._1.id <span class="pl-k">==</span> _.personId
      )
  } <span class="pl-k">yield</span>(p, e, c)
}

ctx.run(qFlat)
ctx.run(qNested)
<span class="pl-c">// SELECT p.id, p.name, p.age, e.id, e.personId, e.name, c.id, c.phone•</span>
<span class="pl-c">// FROM Person p INNER JOIN Employer e ON p.id = e.personId LEFT JOIN Contact c ON c.personId = p.id</span></pre>
  </div> 
  <h4><a id="user-content-query-probing" class="anchor" href="https://github.com/getquill/quill#query-probing" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Query probing</h4> 
  <p>Query probing validates queries against the database at compile time, failing the compilation if it is not valid. The query validation does not alter the database state.</p> 
  <p>This feature is disabled by default. To enable it, mix the <code>QueryProbing</code> trait to the database configuration:</p> 
  <pre><code>lazy val ctx = new MyContext("configKey") with QueryProbing
</code></pre> 
  <p>The context must be created in a separate compilation unit in order to be loaded at compile time. Please use <a href="http://www.scala-sbt.org/0.12.1/docs/Detailed-Topics/Macro-Projects.html" target="_blank">this guide</a> that explains how to create a separate compilation unit for macros, that also serves to the purpose of defining a query-probing-capable context. <code>context</code> could be used instead of <code>macros</code> as the name of the separate compilation unit.</p> 
  <p>The configurations correspondent to the config key must be available at compile time. You can achieve it by adding this line to your project settings:</p> 
  <pre><code>unmanagedClasspath in Compile += baseDirectory.value / "src" / "main" / "resources"
</code></pre> 
  <p>If your project doesn't have a standard layout, e.g. a play project, you should configure the path to point to the folder that contains your config file.</p> 
  <h2><a id="user-content-actions" class="anchor" href="https://github.com/getquill/quill#actions" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Actions</h2> 
  <p>Database actions are defined using quotations as well. These actions don't have a collection-like API but rather a custom DSL to express inserts, deletes and updates.</p> 
  <p><strong>insert</strong></p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">a</span> <span class="pl-k">=</span> quote(query[<span class="pl-en">Contact</span>].insert(lift(<span class="pl-en">Contact</span>(<span class="pl-c1">999</span>, <span class="pl-s"><span class="pl-pds">"</span>+1510488988<span class="pl-pds">"</span></span>))))

ctx.run(a)
<span class="pl-c">// INSERT INTO Contact (personId,phone) VALUES (?, ?)</span></pre>
  </div> 
  <p>It is also possible to insert specific columns:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">a</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Contact</span>].insert(_.personId <span class="pl-k">-</span><span class="pl-k">&gt;</span> lift(<span class="pl-c1">999</span>), _.phone <span class="pl-k">-</span><span class="pl-k">&gt;</span> lift(<span class="pl-s"><span class="pl-pds">"</span>+1510488988<span class="pl-pds">"</span></span>))
}

ctx.run(a)
<span class="pl-c">// INSERT INTO Contact (personId,phone) VALUES (?, ?)</span></pre>
  </div> 
  <p><strong>batch insert</strong></p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">a</span> <span class="pl-k">=</span> quote {
  liftQuery(<span class="pl-en">List</span>(<span class="pl-en">Person</span>(<span class="pl-c1">0</span>, <span class="pl-s"><span class="pl-pds">"</span>John<span class="pl-pds">"</span></span>, <span class="pl-c1">31</span>))).foreach(e <span class="pl-k">=&gt;</span> query[<span class="pl-en">Person</span>].insert(e))
}

ctx.run(a)
<span class="pl-c">// INSERT INTO Person (id,name,age) VALUES (?, ?, ?)</span></pre>
  </div> 
  <p><strong>update</strong></p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">a</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].filter(_.id <span class="pl-k">==</span> <span class="pl-c1">999</span>).update(lift(<span class="pl-en">Person</span>(<span class="pl-c1">999</span>, <span class="pl-s"><span class="pl-pds">"</span>John<span class="pl-pds">"</span></span>, <span class="pl-c1">22</span>)))
}

ctx.run(a)
<span class="pl-c">// UPDATE Person SET id = ?, name = ?, age = ? WHERE id = 999</span></pre>
  </div> 
  <p>Using specific columns:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">a</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].filter(p <span class="pl-k">=&gt;</span> p.id <span class="pl-k">==</span> lift(<span class="pl-c1">999</span>)).update(_.age <span class="pl-k">-</span><span class="pl-k">&gt;</span> lift(<span class="pl-c1">18</span>))
}

ctx.run(a)
<span class="pl-c">// UPDATE Person SET age = ? WHERE id = ?</span></pre>
  </div> 
  <p>Using columns as part of the update:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">a</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].filter(p <span class="pl-k">=&gt;</span> p.id <span class="pl-k">==</span> lift(<span class="pl-c1">999</span>)).update(p <span class="pl-k">=&gt;</span> p.age <span class="pl-k">-</span><span class="pl-k">&gt;</span> (p.age <span class="pl-k">+</span> <span class="pl-c1">1</span>))
}

ctx.run(a)
<span class="pl-c">// UPDATE Person SET age = (age + 1) WHERE id = ?</span></pre>
  </div> 
  <p><strong>batch update</strong></p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">a</span> <span class="pl-k">=</span> quote {
  liftQuery(<span class="pl-en">List</span>(<span class="pl-en">Person</span>(<span class="pl-c1">1</span>, <span class="pl-s"><span class="pl-pds">"</span>name<span class="pl-pds">"</span></span>, <span class="pl-c1">31</span>))).foreach { person <span class="pl-k">=&gt;</span>
     query[<span class="pl-en">Person</span>].filter(_.id <span class="pl-k">==</span> person.id).update(_.name <span class="pl-k">-</span><span class="pl-k">&gt;</span> person.name, _.age <span class="pl-k">-</span><span class="pl-k">&gt;</span> person.age)
  }
}

ctx.run(a)
<span class="pl-c">// UPDATE Person SET name = ?, age = ? WHERE id = ?</span></pre>
  </div> 
  <p><strong>delete</strong></p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">a</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].filter(p <span class="pl-k">=&gt;</span> p.name <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>).delete
}

ctx.run(a)
<span class="pl-c">// DELETE FROM Person WHERE name = ''</span></pre>
  </div> 
  <h2><a id="user-content-implicit-query" class="anchor" href="https://github.com/getquill/quill#implicit-query" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Implicit query</h2> 
  <p>Quill provides implicit conversions from case class companion objects to <code>query[T]</code> through an additional trait:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">ctx</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">SqlMirrorContext</span>[<span class="pl-en">MirrorSqlDialect</span>, <span class="pl-en">Literal</span>] <span class="pl-k">with</span> <span class="pl-e">ImplicitQuery</span>

<span class="pl-k">import</span> <span class="pl-v">ctx.</span><span class="pl-v">_</span>

<span class="pl-k">val</span> <span class="pl-en">q</span> <span class="pl-k">=</span> quote {
  <span class="pl-k">for</span> {
    p <span class="pl-k">&lt;</span><span class="pl-k">-</span> <span class="pl-en">Person</span> <span class="pl-k">if</span>(p.id <span class="pl-k">==</span> <span class="pl-c1">999</span>)
    c <span class="pl-k">&lt;</span><span class="pl-k">-</span> <span class="pl-en">Contact</span> <span class="pl-k">if</span>(c.personId <span class="pl-k">==</span> p.id)
  } <span class="pl-k">yield</span> {
    (p.name, c.phone)
  }
}

ctx.run(q)
<span class="pl-c">// SELECT p.name, c.phone FROM Person p, Contact c WHERE (p.id = 999) AND (c.personId = p.id)</span></pre>
  </div> 
  <p>Note the usage of <code>Person</code> and <code>Contact</code> instead of <code>query[Person]</code> and <code>query[Contact]</code>.</p> 
  <h2><a id="user-content-sql-specific-operations" class="anchor" href="https://github.com/getquill/quill#sql-specific-operations" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>SQL-specific operations</h2> 
  <p>Some operations are sql-specific and not provided with the generic quotation mechanism. The sql contexts provide implicit classes for this kind of operation:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">ctx</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">SqlMirrorContext</span>[<span class="pl-en">MirrorSqlDialect</span>, <span class="pl-en">Literal</span>]
<span class="pl-k">import</span> <span class="pl-v">ctx.</span><span class="pl-v">_</span></pre>
  </div> 
  <p><strong>like</strong></p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">q</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].filter(p <span class="pl-k">=&gt;</span> p.name like <span class="pl-s"><span class="pl-pds">"</span>%John%<span class="pl-pds">"</span></span>)
}
ctx.run(q)
<span class="pl-c">// SELECT p.id, p.name, p.age FROM Person p WHERE p.name like '%John%'</span></pre>
  </div> 
  <h2><a id="user-content-cassandra-specific-operations" class="anchor" href="https://github.com/getquill/quill#cassandra-specific-operations" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Cassandra-specific operations</h2> 
  <p>The cassandra context also provides a few additional operations:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">ctx</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">CassandraMirrorContext</span>
<span class="pl-k">import</span> <span class="pl-v">ctx.</span><span class="pl-v">_</span></pre>
  </div> 
  <p><strong>allowFiltering</strong></p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">q</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].filter(p <span class="pl-k">=&gt;</span> p.age <span class="pl-k">&gt;</span> <span class="pl-c1">10</span>).allowFiltering
}
ctx.run(q)
<span class="pl-c">// SELECT id, name, age FROM Person WHERE age &gt; 10 ALLOW FILTERING</span></pre>
  </div> 
  <p><strong>ifNotExists</strong></p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">q</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].insert(_.age <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-c1">10</span>, _.name <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>John<span class="pl-pds">"</span></span>).ifNotExists
}
ctx.run(q)
<span class="pl-c">// INSERT INTO Person (age,name) VALUES (10, 'John') IF NOT EXISTS</span></pre>
  </div> 
  <p><strong>ifExists</strong></p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">q</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].filter(p <span class="pl-k">=&gt;</span> p.name <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>John<span class="pl-pds">"</span></span>).delete.ifExists
}
ctx.run(q)
<span class="pl-c">// DELETE FROM Person WHERE name = 'John' IF EXISTS</span></pre>
  </div> 
  <p><strong>usingTimestamp</strong></p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">q1</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].insert(_.age <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-c1">10</span>, _.name <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>John<span class="pl-pds">"</span></span>).usingTimestamp(<span class="pl-c1">99</span>)
}
ctx.run(q1)
<span class="pl-c">// INSERT INTO Person (age,name) VALUES (10, 'John') USING TIMESTAMP 99</span>

<span class="pl-k">val</span> <span class="pl-en">q2</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].usingTimestamp(<span class="pl-c1">99</span>).update(_.age <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-c1">10</span>)
}
ctx.run(q2)
<span class="pl-c">// UPDATE Person USING TIMESTAMP 99 SET age = 10</span></pre>
  </div> 
  <p><strong>usingTtl</strong></p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">q1</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].insert(_.age <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-c1">10</span>, _.name <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>John<span class="pl-pds">"</span></span>).usingTtl(<span class="pl-c1">11</span>)
}
ctx.run(q1)
<span class="pl-c">// INSERT INTO Person (age,name) VALUES (10, 'John') USING TTL 11</span>

<span class="pl-k">val</span> <span class="pl-en">q2</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].usingTtl(<span class="pl-c1">11</span>).update(_.age <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-c1">10</span>)
}
ctx.run(q2)
<span class="pl-c">// UPDATE Person USING TTL 11 SET age = 10</span>

<span class="pl-k">val</span> <span class="pl-en">q3</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].usingTtl(<span class="pl-c1">11</span>).filter(_.name <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>John<span class="pl-pds">"</span></span>).delete
}
ctx.run(q3)  
<span class="pl-c">// DELETE FROM Person USING TTL 11 WHERE name = 'John'</span></pre>
  </div> 
  <p><strong>using</strong></p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">q1</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].insert(_.age <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-c1">10</span>, _.name <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>John<span class="pl-pds">"</span></span>).using(ts <span class="pl-k">=</span> <span class="pl-c1">99</span>, ttl <span class="pl-k">=</span> <span class="pl-c1">11</span>)
}
ctx.run(q1)
<span class="pl-c">// INSERT INTO Person (age,name) VALUES (10, 'John') USING TIMESTAMP 99 AND TTL 11</span>

<span class="pl-k">val</span> <span class="pl-en">q2</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].using(ts <span class="pl-k">=</span> <span class="pl-c1">99</span>, ttl <span class="pl-k">=</span> <span class="pl-c1">11</span>).update(_.age <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-c1">10</span>)
}
ctx.run(q2)
<span class="pl-c">// UPDATE Person USING TIMESTAMP 99 AND TTL 11 SET age = 10</span>

<span class="pl-k">val</span> <span class="pl-en">q3</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].using(ts <span class="pl-k">=</span> <span class="pl-c1">99</span>, ttl <span class="pl-k">=</span> <span class="pl-c1">11</span>).filter(_.name <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>John<span class="pl-pds">"</span></span>).delete
}
ctx.run(q3)
<span class="pl-c">// DELETE FROM Person USING TIMESTAMP 99 AND TTL 11 WHERE name = 'John'</span></pre>
  </div> 
  <p><strong>ifCond</strong></p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">q1</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].update(_.age <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-c1">10</span>).ifCond(_.name <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>John<span class="pl-pds">"</span></span>)
}
ctx.run(q1)
<span class="pl-c">// UPDATE Person SET age = 10 IF name = 'John'</span>

<span class="pl-k">val</span> <span class="pl-en">q2</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].filter(_.name <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>John<span class="pl-pds">"</span></span>).delete.ifCond(_.age <span class="pl-k">==</span> <span class="pl-c1">10</span>)
}
ctx.run(q2)
<span class="pl-c">// DELETE FROM Person WHERE name = 'John' IF age = 10</span></pre>
  </div> 
  <p><strong>delete column</strong></p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">q</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].map(p <span class="pl-k">=&gt;</span> p.age).delete
}
ctx.run(q)
<span class="pl-c">// DELETE p.age FROM Person</span></pre>
  </div> 
  <h2><a id="user-content-dynamic-queries" class="anchor" href="https://github.com/getquill/quill#dynamic-queries" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Dynamic queries</h2> 
  <p>Quill's default operation mode is compile-time, but there are queries that have their structure defined only at runtime. Quill automatically falls back to runtime normalization and query generation if the query's structure is not static. Example:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">ctx</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">SqlMirrorContext</span>[<span class="pl-en">MirrorSqlDialect</span>, <span class="pl-en">Literal</span>]

<span class="pl-k">import</span> <span class="pl-v">ctx.</span><span class="pl-v">_</span>

<span class="pl-k">sealed</span> <span class="pl-k">trait</span> <span class="pl-en">QueryType</span>
<span class="pl-k">case</span> <span class="pl-k">object</span> <span class="pl-en">Minor</span> <span class="pl-k">extends</span> <span class="pl-e">QueryType</span>
<span class="pl-k">case</span> <span class="pl-k">object</span> <span class="pl-en">Senior</span> <span class="pl-k">extends</span> <span class="pl-e">QueryType</span>

<span class="pl-k">def</span> <span class="pl-en">people</span>(<span class="pl-v">t</span>: <span class="pl-en">QueryType</span>)<span class="pl-k">:</span> <span class="pl-en">Quoted</span>[<span class="pl-en">Query</span>[<span class="pl-en">Person</span>]] <span class="pl-k">=</span>
  t <span class="pl-k">match</span> {
    <span class="pl-k">case</span> <span class="pl-en">Minor</span> <span class="pl-k">=&gt;</span> quote {
      query[<span class="pl-en">Person</span>].filter(p <span class="pl-k">=&gt;</span> p.age <span class="pl-k">&lt;</span> <span class="pl-c1">18</span>)
    }
    <span class="pl-k">case</span> <span class="pl-en">Senior</span> <span class="pl-k">=&gt;</span> quote {
      query[<span class="pl-en">Person</span>].filter(p <span class="pl-k">=&gt;</span> p.age <span class="pl-k">&gt;</span> <span class="pl-c1">65</span>)
    }
  }

ctx.run(people(<span class="pl-en">Minor</span>))
<span class="pl-c">// SELECT p.id, p.name, p.age FROM Person p WHERE p.age &lt; 18</span>

ctx.run(people(<span class="pl-en">Senior</span>))
<span class="pl-c">// SELECT p.id, p.name, p.age FROM Person p WHERE p.age &gt; 65</span></pre>
  </div> 
  <h1><a id="user-content-extending-quill" class="anchor" href="https://github.com/getquill/quill#extending-quill" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Extending quill</h1> 
  <h2><a id="user-content-infix" class="anchor" href="https://github.com/getquill/quill#infix" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Infix</h2> 
  <p>Infix is a very flexible mechanism to use non-supported features without having to use plain queries in the target language. It allows insertion of arbitrary strings within quotations.</p> 
  <p>For instance, quill doesn't support the <code>FOR UPDATE</code> SQL feature. It can still be used through infix and implicit classes:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">implicit</span> <span class="pl-k">class</span> <span class="pl-en">ForUpdate</span>[<span class="pl-en">T</span>](<span class="pl-v">q</span>: <span class="pl-en">Query</span>[<span class="pl-en">T</span>]) {
  <span class="pl-k">def</span> <span class="pl-en">forUpdate</span> <span class="pl-k">=</span> quote(infix<span class="pl-s"><span class="pl-pds">"</span>$q FOR UPDATE<span class="pl-pds">"</span></span>.as[<span class="pl-en">Query</span>[<span class="pl-en">T</span>]])
}

<span class="pl-k">val</span> <span class="pl-en">a</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].filter(p <span class="pl-k">=&gt;</span> p.age <span class="pl-k">&lt;</span> <span class="pl-c1">18</span>).forUpdate
}

ctx.run(a)
<span class="pl-c">// SELECT p.id, p.name, p.age FROM (SELECT * FROM Person p WHERE p.age &lt; 18 FOR UPDATE) p</span></pre>
  </div> 
  <p>The <code>forUpdate</code> quotation can be reused for multiple queries.</p> 
  <p>A custom database function can also be used through infix:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">myFunction</span> <span class="pl-k">=</span> quote {
  (<span class="pl-v">i</span>: <span class="pl-k">Int</span>) <span class="pl-k">=&gt;</span> infix<span class="pl-s"><span class="pl-pds">"</span>MY_FUNCTION($i)<span class="pl-pds">"</span></span>.as[<span class="pl-k">Int</span>]
}

<span class="pl-k">val</span> <span class="pl-en">q</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].map(p <span class="pl-k">=&gt;</span> myFunction(p.age))
}

ctx.run(q)
<span class="pl-c">// SELECT MY_FUNCTION(p.age) FROM Person p</span></pre>
  </div> 
  <h2><a id="user-content-custom-encoding" class="anchor" href="https://github.com/getquill/quill#custom-encoding" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Custom encoding</h2> 
  <p>Quill uses <code>Encoder</code>s to encode query inputs and <code>Decoder</code>s to read values returned by queries. The library provides a few built-in encodings and two mechanisms to define custom encodings: mapped encoding and raw encoding.</p> 
  <h2><a id="user-content-mapped-encoding" class="anchor" href="https://github.com/getquill/quill#mapped-encoding" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Mapped Encoding</h2> 
  <p>If the correspondent database type is already supported, use <code>MappedEncoding</code>. In this example, <code>String</code> is already supported by Quill and the <code>UUID</code> encoding from/to <code>String</code> is defined through mapped encoding:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">ctx.</span><span class="pl-v">_</span>
<span class="pl-k">import</span> <span class="pl-v">java.util.</span><span class="pl-v">UUID</span>

<span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">encodeUUID</span> <span class="pl-k">=</span> <span class="pl-en">MappedEncoding</span>[<span class="pl-en">UUID</span>, <span class="pl-k">String</span>](_.toString)
<span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">decodeUUID</span> <span class="pl-k">=</span> <span class="pl-en">MappedEncoding</span>[<span class="pl-k">String</span>, <span class="pl-en">UUID</span>](<span class="pl-en">UUID</span>.fromString(_))</pre>
  </div> 
  <p>A mapped encoding also can be defined without a context instance by importing <code>io.getquill.MappedEncoding</code>:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">io.getquill.</span><span class="pl-v">MappedEncoding</span>
<span class="pl-k">import</span> <span class="pl-v">java.util.</span><span class="pl-v">UUID</span>

<span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">encodeUUID</span> <span class="pl-k">=</span> <span class="pl-en">MappedEncoding</span>[<span class="pl-en">UUID</span>, <span class="pl-k">String</span>](_.toString)
<span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">decodeUUID</span> <span class="pl-k">=</span> <span class="pl-en">MappedEncoding</span>[<span class="pl-k">String</span>, <span class="pl-en">UUID</span>](<span class="pl-en">UUID</span>.fromString(_))</pre>
  </div> 
  <h2><a id="user-content-raw-encoding" class="anchor" href="https://github.com/getquill/quill#raw-encoding" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Raw Encoding</h2> 
  <p>If the database type is not supported by Quill, it is possible to provide "raw" encoders and decoders:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">trait</span> <span class="pl-en">UUIDEncodingExample</span> {
  <span class="pl-k">val</span> <span class="pl-en">jdbcContext</span><span class="pl-k">:</span> <span class="pl-en">JdbcContext</span>[<span class="pl-en">PostgresDialect</span>, <span class="pl-en">Literal</span>] <span class="pl-c">// your context should go here</span>

  <span class="pl-k">import</span> <span class="pl-v">jdbcContext.</span><span class="pl-v">_</span>

  <span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">uuidDecoder</span><span class="pl-k">:</span> <span class="pl-en">Decoder</span>[<span class="pl-en">UUID</span>] <span class="pl-k">=</span>
    decoder(java.sql.<span class="pl-en">Types</span>.<span class="pl-en">OTHER</span>, (index, row) <span class="pl-k">=&gt;</span> 
      <span class="pl-en">UUID</span>.fromString(row.getObject(index).toString)) <span class="pl-c">// database-specific implementation</span>

  <span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">uuidEncoder</span><span class="pl-k">:</span> <span class="pl-en">Encoder</span>[<span class="pl-en">UUID</span>] <span class="pl-k">=</span>
    encoder(java.sql.<span class="pl-en">Types</span>.<span class="pl-en">OTHER</span>, (index, value, row) <span class="pl-k">=&gt;</span>
        row.setObject(index, value, java.sql.<span class="pl-en">Types</span>.<span class="pl-en">OTHER</span>)) <span class="pl-c">// database-specific implementation</span>
}</pre>
  </div> 
  <h2><a id="user-content-anyval" class="anchor" href="https://github.com/getquill/quill#anyval" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a><code>AnyVal</code></h2> 
  <p>Quill automatically encodes <code>AnyVal</code>s:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">UserId</span>(<span class="pl-v">value</span>: <span class="pl-k">Int</span>) <span class="pl-k">extends</span> <span class="pl-e">AnyVal</span>
<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">User</span>(<span class="pl-v">id</span>: <span class="pl-en">UserId</span>, <span class="pl-v">name</span>: <span class="pl-k">String</span>)

<span class="pl-k">val</span> <span class="pl-en">q</span> <span class="pl-k">=</span> quote {
  <span class="pl-k">for</span> {
    u <span class="pl-k">&lt;</span><span class="pl-k">-</span> query[<span class="pl-en">User</span>] <span class="pl-k">if</span> u.id <span class="pl-k">==</span> lift(<span class="pl-en">UserId</span>(<span class="pl-c1">1</span>))
  } <span class="pl-k">yield</span> u
}

ctx.run(q)
<span class="pl-c">// SELECT u.id, u.name FROM User u WHERE (u.id = 1)</span></pre>
  </div> 
  <h2><a id="user-content-meta-dsl" class="anchor" href="https://github.com/getquill/quill#meta-dsl" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Meta DSL</h2> 
  <p>The meta DSL allows the user to customize how Quill handles the expansion and execution of quotations through implicit meta instances.</p> 
  <p><strong>Schema meta</strong></p> 
  <p>By default, quill expands <code>query[Person]</code> to <code>querySchema[Person]("Person")</code>. It's possible to customize this behavior using an implicit instance of <code>SchemaMeta</code>:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">personSchemaMeta</span> <span class="pl-k">=</span> schemaMeta[<span class="pl-en">Person</span>](<span class="pl-s"><span class="pl-pds">"</span>people<span class="pl-pds">"</span></span>, _.id <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>person_id<span class="pl-pds">"</span></span>)

ctx.run(query[<span class="pl-en">Person</span>])
<span class="pl-c">// SELECT x.person_id, x.name, x.age FROM people x</span></pre>
  </div> 
  <p><strong>Insert meta</strong></p> 
  <p><code>InsertMeta</code> customizes the expansion of case classes for insert actions (<code>query[Person].insert(p)</code>). By default, all columns are expanded and through an implicit <code>InsertMeta</code>, it's possible to exclude columns from the expansion:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">personInsertMeta</span> <span class="pl-k">=</span> insertMeta[<span class="pl-en">Person</span>](_.id)

ctx.run(query[<span class="pl-en">Person</span>].insert(lift(<span class="pl-en">Person</span>(<span class="pl-k">-</span><span class="pl-c1">1</span>, <span class="pl-s"><span class="pl-pds">"</span>John<span class="pl-pds">"</span></span>, <span class="pl-c1">22</span>))))
<span class="pl-c">// INSERT INTO Person (name,age) VALUES (?, ?)</span></pre>
  </div> 
  <p>Note that the parameter of <code>insertMeta</code> is called <code>exclude</code>, but it isn't possible to use named parameters for macro invocations.</p> 
  <p><strong>Update meta</strong></p> 
  <p><code>UpdateMeta</code> customizes the expansion of case classes for update actions (<code>query[Person].update(p)</code>). By default, all columns are expanded, and through an implicit <code>UpdateMeta</code>, it's possible to exclude columns from the expansion:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">personUpdateMeta</span> <span class="pl-k">=</span> updateMeta[<span class="pl-en">Person</span>](_.id)

ctx.run(query[<span class="pl-en">Person</span>].filter(_.id <span class="pl-k">==</span> <span class="pl-c1">1</span>).update(lift(<span class="pl-en">Person</span>(<span class="pl-c1">1</span>, <span class="pl-s"><span class="pl-pds">"</span>John<span class="pl-pds">"</span></span>, <span class="pl-c1">22</span>))))
<span class="pl-c">// UPDATE Person SET name = ?, age = ? WHERE id = 1</span></pre>
  </div> 
  <p>Note that the parameter of <code>updateMeta</code> is called <code>exclude</code>, but it isn't possible to use named parameters for macro invocations.</p> 
  <p><strong>Query meta</strong></p> 
  <p>This kind of meta instance customizes the expansion of query types and extraction of the final value. For instance, it's possible to use this feature to normalize values before reading them from the database:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">personQueryMeta</span> <span class="pl-k">=</span> 
  queryMeta(
    (<span class="pl-v">q</span>: <span class="pl-en">Query</span>[<span class="pl-en">Person</span>]) <span class="pl-k">=&gt;</span>
      q.map(p <span class="pl-k">=&gt;</span> (p.id, infix<span class="pl-s"><span class="pl-pds">"</span>CONVERT(${p.name} USING utf8)<span class="pl-pds">"</span></span>.as[<span class="pl-k">String</span>], p.age))
  ) {
    <span class="pl-k">case</span> (id, name, age) <span class="pl-k">=&gt;</span>
      <span class="pl-en">Person</span>(id, name, age)
  }</pre>
  </div> 
  <p>The query meta definition is open and allows the user to even join values from other tables before reading the final value. This kind of usage is not encouraged.</p> 
  <h1><a id="user-content-contexts" class="anchor" href="https://github.com/getquill/quill#contexts" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Contexts</h1> 
  <p>Contexts represent the database and provide an execution interface for queries.</p> 
  <h2><a id="user-content-mirror-context" class="anchor" href="https://github.com/getquill/quill#mirror-context" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Mirror context</h2> 
  <p>Quill provides mirror context for test purposes. Instead of running the query, mirror context return a structure with the information that would be used to run the query. There are three mirror context instances:</p> 
  <ul> 
   <li><code>io.getquill.MirrorContext</code>: Mirrors the quotation AST</li> 
   <li><code>io.getquill.SqlMirrorContext</code>: Mirrors the SQL query</li> 
   <li><code>io.getquill.CassandraMirrorContext</code>: Mirrors the CQL query</li> 
  </ul> 
  <h2><a id="user-content-dependent-contexts" class="anchor" href="https://github.com/getquill/quill#dependent-contexts" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Dependent contexts</h2> 
  <p>The context instance provides all methods and types to interact with quotations and the database. Depending on how the context import happens, Scala won't be able to infer that the types are compatible.</p> 
  <p>For instance, this example <strong>will not</strong> compile:</p> 
  <pre><code>class MyContext extends SqlMirrorContext[MirrorSqlDialect, Literal]

case class MySchema(c: MyContext) {

  import c._
  val people = quote {

    querySchema[Person]("people")
  }
}

case class MyDao(c: MyContext, schema: MySchema) {

  def allPeople = 
    c.run(schema.people)
// ERROR: [T](quoted: MyDao.this.c.Quoted[MyDao.this.c.Query[T]])MyDao.this.c.QueryResult[T]
 cannot be applied to (MyDao.this.schema.c.Quoted[MyDao.this.schema.c.EntityQuery[Person]]{def quoted: io.getquill.ast.ConfiguredEntity; def ast: io.getquill.ast.ConfiguredEntity; def id1854281249(): Unit; val bindings: Object})
}
</code></pre> 
  <p>One alternative to work with this kind of context import is use traits with abstract context values:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">class</span> <span class="pl-en">MyContext</span> <span class="pl-k">extends</span> <span class="pl-e">SqlMirrorContext</span>[<span class="pl-en">MirrorSqlDialect</span>, <span class="pl-en">Literal</span>]

<span class="pl-k">trait</span> <span class="pl-en">MySchema</span> {

  <span class="pl-k">val</span> <span class="pl-en">c</span><span class="pl-k">:</span> <span class="pl-en">MyContext</span>
  <span class="pl-k">import</span> <span class="pl-v">c.</span><span class="pl-v">_</span>

  <span class="pl-k">val</span> <span class="pl-en">people</span> <span class="pl-k">=</span> quote {
    querySchema[<span class="pl-en">Person</span>](<span class="pl-s"><span class="pl-pds">"</span>people<span class="pl-pds">"</span></span>)
  }
}

<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">MyDao</span>(<span class="pl-v">c</span>: <span class="pl-en">MyContext</span>) <span class="pl-k">extends</span> <span class="pl-e">MySchema</span> {
  <span class="pl-k">import</span> <span class="pl-v">c.</span><span class="pl-v">_</span>

  <span class="pl-k">def</span> <span class="pl-en">allPeople</span> <span class="pl-k">=</span> 
    c.run(people)
}</pre>
  </div> 
  <h2><a id="user-content-sql-contexts" class="anchor" href="https://github.com/getquill/quill#sql-contexts" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>SQL Contexts</h2> 
  <p>Example:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">lazy</span> <span class="pl-k">val</span> <span class="pl-en">ctx</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">JdbcContext</span>[<span class="pl-en">MySQLDialect</span>, <span class="pl-en">SnakeCase</span>](<span class="pl-s"><span class="pl-pds">"</span>ctx<span class="pl-pds">"</span></span>)</pre>
  </div> 
  <h4><a id="user-content-dialect" class="anchor" href="https://github.com/getquill/quill#dialect" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Dialect</h4> 
  <p>The SQL dialect to be used by the context is defined by the first type parameter. Some context types are specific to a database and thus not require it.</p> 
  <p>Quill has three built-in dialects:</p> 
  <ul> 
   <li><code>io.getquill.H2Dialect</code></li> 
   <li><code>io.getquill.MySQLDialect</code></li> 
   <li><code>io.getquill.PostgresDialect</code></li> 
   <li><code>io.getquill.SqliteDialect</code></li> 
  </ul> 
  <h4><a id="user-content-naming-strategy" class="anchor" href="https://github.com/getquill/quill#naming-strategy" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Naming strategy</h4> 
  <p>The second type parameter defines the naming strategy to be used when translating identifiers (table and column names) to SQL.</p> 
  <table>
   <thead> 
    <tr> 
     <th>strategy</th> 
     <th>example</th> 
    </tr> 
   </thead>
   <tbody> 
    <tr> 
     <td><code>io.getquill.naming.Literal</code></td> 
     <td>some_ident -&gt; some_ident</td> 
    </tr> 
    <tr> 
     <td><code>io.getquill.naming.Escape</code></td> 
     <td>some_ident -&gt; "some_ident"</td> 
    </tr> 
    <tr> 
     <td><code>io.getquill.naming.UpperCase</code></td> 
     <td>some_ident -&gt; SOME_IDENT</td> 
    </tr> 
    <tr> 
     <td><code>io.getquill.naming.LowerCase</code></td> 
     <td>SOME_IDENT -&gt; some_ident</td> 
    </tr> 
    <tr> 
     <td><code>io.getquill.naming.SnakeCase</code></td> 
     <td>someIdent -&gt; some_ident</td> 
    </tr> 
    <tr> 
     <td><code>io.getquill.naming.CamelCase</code></td> 
     <td>some_ident -&gt; someIdent</td> 
    </tr> 
    <tr> 
     <td><code>io.getquill.naming.MysqlEscape</code></td> 
     <td>some_ident -&gt; `some_ident`</td> 
    </tr> 
    <tr> 
     <td><code>io.getquill.naming.PostgresEscape</code></td> 
     <td>$some_ident -&gt; $some_ident</td> 
    </tr> 
   </tbody>
  </table> 
  <p>Multiple transformations can be defined using mixin. For instance, the naming strategy</p> 
  <p><code>SnakeCase with UpperCase</code></p> 
  <p>produces the following transformation:</p> 
  <p><code>someIdent -&gt; SOME_IDENT</code></p> 
  <p>The transformations are applied from left to right.</p> 
  <h4><a id="user-content-configuration" class="anchor" href="https://github.com/getquill/quill#configuration" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Configuration</h4> 
  <p>The string passed to the context is used as the key to obtain configurations using the <a href="http://github.com/typesafehub/config" target="_blank">typesafe config</a> library.</p> 
  <p>Additionally, the contexts provide multiple constructors. For instance, with <code>JdbcContext</code> it's possible to specify a <code>DataSource</code> directly, without using the configuration:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">def</span> <span class="pl-en">createDataSource</span><span class="pl-k">:</span> javax.sql.<span class="pl-en">DataSource</span> <span class="pl-k">with</span> <span class="pl-e">java.io.Closeable</span> <span class="pl-k">=</span> <span class="pl-k">???</span>

<span class="pl-k">lazy</span> <span class="pl-k">val</span> <span class="pl-en">ctx</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">JdbcContext</span>[<span class="pl-en">MySQLDialect</span>, <span class="pl-en">SnakeCase</span>](createDataSource)</pre>
  </div> 
  <h5><a id="user-content-quill-jdbc" class="anchor" href="https://github.com/getquill/quill#quill-jdbc" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>quill-jdbc</h5> 
  <p>Quill uses <a href="https://github.com/brettwooldridge/HikariCP" target="_blank">HikariCP</a> for connection pooling. Please refer to HikariCP's <a href="https://github.com/brettwooldridge/HikariCP#configuration-knobs-baby" target="_blank">documentation</a> for a detailed explanation of the available configurations.</p> 
  <p>Note that there are <code>dataSource</code> configurations, that go under <code>dataSource</code>, like <code>user</code> and <code>password</code>, but some pool settings may go under the root config, like <code>connectionTimeout</code>.</p> 
  <p><strong>Transactions</strong></p> 
  <p>The <code>JdbcContext</code> provides thread-local transaction support:</p> 
  <pre><code>ctx.transaction {
  ctx.run(query[Person].delete)
  // other transactional code
}
</code></pre> 
  <p>The body of <code>transaction</code> can contain calls to other methods and multiple <code>run</code> calls, since the transaction is propagated through a thread-local.</p> 
  <p><strong>MySQL</strong></p> 
  <p>sbt dependencies</p> 
  <pre><code>libraryDependencies ++= Seq(
  "mysql" % "mysql-connector-java" % "5.1.38",
  "io.getquill" %% "quill-jdbc" % "1.0.2-SNAPSHOT"
)
</code></pre> 
  <p>context definition</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">lazy</span> <span class="pl-k">val</span> <span class="pl-en">ctx</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">JdbcContext</span>[<span class="pl-en">MySQLDialect</span>, <span class="pl-en">SnakeCase</span>](<span class="pl-s"><span class="pl-pds">"</span>ctx<span class="pl-pds">"</span></span>)</pre>
  </div> 
  <p>application.properties</p> 
  <pre><code>ctx.dataSourceClassName=com.mysql.jdbc.jdbc2.optional.MysqlDataSource
ctx.dataSource.url=jdbc:mysql://host/database
ctx.dataSource.user=root
ctx.dataSource.password=root
ctx.dataSource.cachePrepStmts=true
ctx.dataSource.prepStmtCacheSize=250
ctx.dataSource.prepStmtCacheSqlLimit=2048
ctx.connectionTimeout=30000
</code></pre> 
  <p><strong>Postgres</strong></p> 
  <p>sbt dependencies</p> 
  <pre><code>libraryDependencies ++= Seq(
  "org.postgresql" % "postgresql" % "9.4.1208",
  "io.getquill" %% "quill-jdbc" % "1.0.2-SNAPSHOT"
)
</code></pre> 
  <p>context definition</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">lazy</span> <span class="pl-k">val</span> <span class="pl-en">ctx</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">JdbcContext</span>[<span class="pl-en">PostgresDialect</span>, <span class="pl-en">SnakeCase</span>](<span class="pl-s"><span class="pl-pds">"</span>ctx<span class="pl-pds">"</span></span>)</pre>
  </div> 
  <p>application.properties</p> 
  <pre><code>ctx.dataSourceClassName=org.postgresql.ds.PGSimpleDataSource
ctx.dataSource.user=root
ctx.dataSource.password=root
ctx.dataSource.databaseName=database
ctx.dataSource.portNumber=5432
ctx.dataSource.serverName=host
ctx.connectionTimeout=30000
</code></pre> 
  <p><strong>Sqlite</strong></p> 
  <p>sbt dependencies</p> 
  <pre><code>libraryDependencies ++= Seq(
  "org.xerial" % "sqlite-jdbc" % "3.8.11.2",
  "io.getquill" %% "quill-jdbc" % "1.0.2-SNAPSHOT"
)
</code></pre> 
  <p>context definition</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">lazy</span> <span class="pl-k">val</span> <span class="pl-en">ctx</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">JdbcContext</span>[<span class="pl-en">SqliteDialect</span>, <span class="pl-en">SnakeCase</span>](<span class="pl-s"><span class="pl-pds">"</span>ctx<span class="pl-pds">"</span></span>)</pre>
  </div> 
  <p>application.properties</p> 
  <pre><code>ctx.driverClassName=org.sqlite.JDBC
ctx.jdbcUrl="jdbc:sqlite:/path/to/db/file.db"
</code></pre> 
  <p><strong>H2</strong></p> 
  <p>sbt dependencies</p> 
  <pre><code>libraryDependencies ++= Seq(
  "com.h2database" % "h2" % "1.4.192",
  "io.getquill" %% "quill-jdbc" % "1.0.2-SNAPSHOT"
)
</code></pre> 
  <p>context definition</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">lazy</span> <span class="pl-k">val</span> <span class="pl-en">ctx</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">JdbcContext</span>[<span class="pl-en">H2Dialect</span>, <span class="pl-en">SnakeCase</span>](<span class="pl-s"><span class="pl-pds">"</span>ctx<span class="pl-pds">"</span></span>)</pre>
  </div> 
  <p>application.properties</p> 
  <pre><code>ctx.dataSourceClassName=org.h2.jdbcx.JdbcDataSource
ctx.dataSource.url="jdbc:h2:mem:yourdbname"
ctx.dataSource.user=sa
</code></pre> 
  <h5><a id="user-content-quill-async" class="anchor" href="https://github.com/getquill/quill#quill-async" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>quill-async</h5> 
  <p><strong>Transactions</strong></p> 
  <p>The async module provides transaction support based on a custom implicit execution context:</p> 
  <pre><code>ctx.transaction { implicit ec =&gt;
  ctx.run(query[Person].delete)
  // other transactional code
}
</code></pre> 
  <p>The body of <code>transaction</code> can contain calls to other methods and multiple <code>run</code> calls, but the transactional code must be done using the provided implicit execution context. For instance:</p> 
  <pre><code>def deletePerson(name: String)(implicit ec: ExecutionContext) = 
  ctx.run(query[Person].filter(_.name == lift(name)).delete)

ctx.transaction { implicit ec =&gt;
  deletePerson("John")
}
</code></pre> 
  <p>Depending on how the main execution context is imported, it is possible to produce an ambigous implicit resolution. A way to solve this problem is shadowing the multiple implicits by using the same name:</p> 
  <pre><code>import scala.concurrent.ExecutionContext.Implicits.{ global =&gt; ec }

def deletePerson(name: String)(implicit ec: ExecutionContext) = 
  ctx.run(query[Person].filter(_.name == lift(name)).delete)

ctx.transaction { implicit ec =&gt;
  deletePerson("John")
}
</code></pre> 
  <p>Note that the global execution context is renamed to ec.</p> 
  <p><strong>MySQL Async</strong></p> 
  <p>sbt dependencies</p> 
  <pre><code>libraryDependencies ++= Seq(
  "io.getquill" %% "quill-async-mysql" % "1.0.2-SNAPSHOT"
)
</code></pre> 
  <p>context definition</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">lazy</span> <span class="pl-k">val</span> <span class="pl-en">ctx</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">MysqlAsyncContext</span>[<span class="pl-en">SnakeCase</span>](<span class="pl-s"><span class="pl-pds">"</span>ctx<span class="pl-pds">"</span></span>)</pre>
  </div> 
  <p>application.properties</p> 
  <pre><code>ctx.host=host
ctx.port=3306
ctx.user=root
ctx.password=root
ctx.database=database
ctx.poolMaxQueueSize=4
ctx.poolMaxObjects=4
ctx.poolMaxIdle=999999999
ctx.poolValidationInterval=10000
ctx.sslmode=disable # optional, one of [disable|prefer|require|verify-ca|verify-full]
ctx.sslrootcert="./path/to/cert/file" # optional, required for sslmode=verify-ca or verify-full
</code></pre> 
  <p><strong>Postgres Async</strong></p> 
  <p>sbt dependencies</p> 
  <pre><code>libraryDependencies ++= Seq(
  "io.getquill" %% "quill-async-postgres" % "1.0.2-SNAPSHOT"
)
</code></pre> 
  <p>context definition</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">lazy</span> <span class="pl-k">val</span> <span class="pl-en">ctx</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">PostgresAsyncContext</span>[<span class="pl-en">SnakeCase</span>](<span class="pl-s"><span class="pl-pds">"</span>ctx<span class="pl-pds">"</span></span>)</pre>
  </div> 
  <p>application.properties</p> 
  <pre><code>ctx.host=host
ctx.port=5432
ctx.user=root
ctx.password=root
ctx.database=database
ctx.poolMaxQueueSize=4
ctx.poolMaxObjects=4
ctx.poolMaxIdle=999999999
ctx.poolValidationInterval=10000
ctx.sslmode=disable # optional, one of [disable|prefer|require|verify-ca|verify-full]
ctx.sslrootcert="./path/to/cert/file" # optional, required for sslmode=verify-ca or verify-full
</code></pre> 
  <h5><a id="user-content-quill-finagle-mysql" class="anchor" href="https://github.com/getquill/quill#quill-finagle-mysql" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>quill-finagle-mysql</h5> 
  <p><strong>Transactions</strong></p> 
  <p>The finagle context provides transaction support through a <code>Local</code> value. See twitter util's <a href="https://github.com/twitter/util/blob/ee8d3140ba0ecc16b54591bd9d8961c11b999c0d/util-core/src/main/scala/com/twitter/util/Local.scala#L96" target="_blank">scaladoc</a> for more details.</p> 
  <pre><code>ctx.transaction {
  ctx.run(query[Person].delete)
  // other transactional code
}
</code></pre> 
  <p>The body of <code>transaction</code> can contain calls to other methods and multiple <code>run</code> calls, since the transaction is automatically propagated through the <code>Local</code> value.</p> 
  <p>sbt dependencies</p> 
  <pre><code>libraryDependencies ++= Seq(
  "io.getquill" %% "quill-finagle-mysql" % "1.0.2-SNAPSHOT"
)
</code></pre> 
  <p>context definition</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">lazy</span> <span class="pl-k">val</span> <span class="pl-en">ctx</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">FinagleMysqlContext</span>[<span class="pl-en">SnakeCase</span>](<span class="pl-s"><span class="pl-pds">"</span>ctx<span class="pl-pds">"</span></span>)</pre>
  </div> 
  <p>application.properties</p> 
  <pre><code>ctx.dest=localhost:3306
ctx.user=root
ctx.password=root
ctx.database=database
ctx.pool.watermark.low=0
ctx.pool.watermark.high=10
ctx.pool.idleTime=5 # seconds
ctx.pool.bufferSize=0
ctx.pool.maxWaiters=2147483647
</code></pre> 
  <h5><a id="user-content-quill-finagle-postgres" class="anchor" href="https://github.com/getquill/quill#quill-finagle-postgres" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>quill-finagle-postgres</h5> 
  <p><strong>Transactions</strong></p> 
  <p>The finagle context provides transaction support through a <code>Local</code> value. See twitter util's <a href="https://github.com/twitter/util/blob/ee8d3140ba0ecc16b54591bd9d8961c11b999c0d/util-core/src/main/scala/com/twitter/util/Local.scala#L96" target="_blank">scaladoc</a> for more details.</p> 
  <pre><code>ctx.transaction {
  ctx.run(query[Person].delete)
  // other transactional code
}
</code></pre> 
  <p>The body of <code>transaction</code> can contain calls to other methods and multiple <code>run</code> calls, since the transaction is automatically propagated through the <code>Local</code> value.</p> 
  <p>sbt dependencies</p> 
  <pre><code>libraryDependencies ++= Seq(
  "io.getquill" %% "quill-finagle-postgres" % "1.0.2-SNAPSHOT"
)
</code></pre> 
  <p>context definition</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">lazy</span> <span class="pl-k">val</span> <span class="pl-en">ctx</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">FinaglePostgresContext</span>[<span class="pl-en">SnakeCase</span>](<span class="pl-s"><span class="pl-pds">"</span>ctx<span class="pl-pds">"</span></span>)</pre>
  </div> 
  <p>application.properties</p> 
  <pre><code>ctx.host=localhost:3306
ctx.user=root
ctx.password=root
ctx.database=database
ctx.useSsl=false
ctx.hostConnectionLimit=1
ctx.numRetries=4
ctx.binaryResults=false
ctx.binaryParams=false
</code></pre> 
  <h2><a id="user-content-cassandra-contexts" class="anchor" href="https://github.com/getquill/quill#cassandra-contexts" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Cassandra Contexts</h2> 
  <p>sbt dependencies</p> 
  <pre><code>libraryDependencies ++= Seq(
  "io.getquill" %% "quill-cassandra" % "1.0.2-SNAPSHOT"
)
</code></pre> 
  <p><strong>synchronous context</strong></p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">lazy</span> <span class="pl-k">val</span> <span class="pl-en">ctx</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">CassandraSyncContext</span>[<span class="pl-en">SnakeCase</span>](<span class="pl-s"><span class="pl-pds">"</span>ctx<span class="pl-pds">"</span></span>)</pre>
  </div> 
  <p><strong>asynchronous context</strong></p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">lazy</span> <span class="pl-k">val</span> <span class="pl-en">ctx</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">CassandraAsyncContext</span>[<span class="pl-en">SnakeCase</span>](<span class="pl-s"><span class="pl-pds">"</span>ctx<span class="pl-pds">"</span></span>)</pre>
  </div> 
  <p><strong>stream context</strong></p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">lazy</span> <span class="pl-k">val</span> <span class="pl-en">ctx</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">CassandraStreamContext</span>[<span class="pl-en">SnakeCase</span>](<span class="pl-s"><span class="pl-pds">"</span>ctx<span class="pl-pds">"</span></span>)</pre>
  </div> 
  <p>The configurations are set using runtime reflection on the <a href="https://docs.datastax.com/en/drivers/java/2.1/com/datastax/driver/core/Cluster.Builder.html" target="_blank"><code>Cluster.builder</code></a> instance. It is possible to set nested structures like <code>queryOptions.consistencyLevel</code>, use enum values like <code>LOCAL_QUORUM</code>, and set multiple parameters like in <code>credentials</code>.</p> 
  <p>application.properties</p> 
  <pre><code>ctx.keyspace=quill_test
ctx.preparedStatementCacheSize=1000
ctx.session.contactPoint=127.0.0.1
ctx.session.withPort=9042
ctx.session.queryOptions.consistencyLevel=LOCAL_QUORUM
ctx.session.withoutMetrics=true
ctx.session.withoutJMXReporting=false
ctx.session.credentials.0=root
ctx.session.credentials.1=pass
ctx.session.maxSchemaAgreementWaitSeconds=1
ctx.session.addressTranslater=com.datastax.driver.core.policies.IdentityTranslater
</code></pre> 
  <h1><a id="user-content-additional-resources" class="anchor" href="https://github.com/getquill/quill#additional-resources" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Additional resources</h1> 
  <h2><a id="user-content-templates" class="anchor" href="https://github.com/getquill/quill#templates" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Templates</h2> 
  <p>In order to quickly start with Quill, we have setup some template projects:</p> 
  <ul> 
   <li><a href="https://github.com/getquill/play-quill-jdbc" target="_blank">Play Framework with Quill JDBC</a></li> 
  </ul> 
  <h2><a id="user-content-slick-comparison" class="anchor" href="https://github.com/getquill/quill#slick-comparison" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Slick comparison</h2> 
  <p>Please refer to <a href="https://github.com/getquill/quill/blob/master/SLICK.md" target="_blank">SLICK.md</a> for a detailed comparison between Quill and Slick.</p> 
  <h2><a id="user-content-cassandra-libraries-comparison" class="anchor" href="https://github.com/getquill/quill#cassandra-libraries-comparison" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Cassandra libraries comparison</h2> 
  <p>Please refer to <a href="https://github.com/getquill/quill/blob/master/CASSANDRA.md" target="_blank">CASSANDRA.md</a> for a detailed comparison between Quill and other main alternatives for interaction with Cassandra in Scala.</p> 
  <h2><a id="user-content-external-content" class="anchor" href="https://github.com/getquill/quill#external-content" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>External content</h2> 
  <p><strong>Talks</strong></p> 
  <p>ScalaDays Berlin 2016 - <a href="https://www.youtube.com/watch?v=nqSYccoSeio" target="_blank">Scylla, Charybdis, and the mystery of Quill</a></p> 
  <p><strong>Blog posts</strong></p> 
  <p>Scalac.io blog - <a href="http://blog.scalac.io/2016/07/21/compile-time-queries-with-quill.html" target="_blank">Compile-time Queries with Quill</a></p> 
  <p><strong>Tools</strong></p> 
  <p>Code/boilerplate generator from db schema - <a href="https://github.com/olafurpg/scala-db-codegen" target="_blank">scala-db-codegen</a></p> 
  <h2><a id="user-content-code-of-conduct" class="anchor" href="https://github.com/getquill/quill#code-of-conduct" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Code of Conduct</h2> 
  <p>Please note that this project is released with a Contributor Code of Conduct. By participating in this project you agree to abide by its terms. See <a href="https://github.com/getquill/quill/blob/master/CODE_OF_CONDUCT.md" target="_blank">CODE_OF_CONDUCT.md</a> for details.</p> 
  <h2><a id="user-content-license" class="anchor" href="https://github.com/getquill/quill#license" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>License</h2> 
  <p>See the <a href="https://github.com/getquill/quill/blob/master/LICENSE.txt" target="_blank">LICENSE</a> file for details.</p> 
  <h1><a id="user-content-maintainers" class="anchor" href="https://github.com/getquill/quill#maintainers" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Maintainers</h1> 
  <ul> 
   <li>@fwbrasil</li> 
   <li>@godenji</li> 
   <li>@gustavoamigo</li> 
   <li>@jilen</li> 
   <li>@lvicentesanchez</li> 
   <li>@mxl</li> 
  </ul> 
  <p>You can notify all maintainers using the handle <code>@getquill/maintainers</code>.</p> 
  <h1><a id="user-content-acknowledgments" class="anchor" href="https://github.com/getquill/quill#acknowledgments" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Acknowledgments</h1> 
  <p>The project was created having Philip Wadler's talk <a href="http://www.infoq.com/presentations/theory-language-integrated-query" target="_blank">"A practical theory of language-integrated query"</a> as its initial inspiration. The development was heavily influenced by the following papers:</p> 
  <ul> 
   <li><a href="http://homepages.inf.ed.ac.uk/slindley/papers/practical-theory-of-linq.pdf" target="_blank">A Practical Theory of Language-Integrated Query</a></li> 
   <li><a href="http://homepages.inf.ed.ac.uk/wadler/papers/qdsl/qdsl.pdf" target="_blank">Everything old is new again: Quoted Domain Specific Languages</a></li> 
   <li><a href="http://db.inf.uni-tuebingen.de/staticfiles/publications/the-flatter-the-better.pdf" target="_blank">The Flatter, the Better</a></li> 
  </ul> 
 </article>
</div>